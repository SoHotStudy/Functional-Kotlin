# 펑터, 어플리커티브, 모나드

## 펑터

- map: 래핑된 값에 함수를 적용해 외부 타입은 바꾸지 않고 내부 값만 변경
    - ex. List<T>의 map(transform: (T) → R): List<R>
- transform 함수를 인자로 받는 map 메소드를 제공하는 타입

```kotlin
interface Functor<C<_>> {
  fun <A, B> map(ca: C<A>, transform: (A) -> B): C<B>
}

// Option 타입의 map 함수
fun <T, R> Option<T>.map(transform: (T) -> R): Option<R> = when (this) {
  Option.None -> Option.None
  is Option.Some -> Option.Some(transform(value))
}
```
	
- 왜 쓰는 걸까?
    - 일반적으로 모델링할 수 없는 상황을 모델링 할 수 있음
        - ex 1. 값이 미래에 준비되는 경우 (ex. Promise)
        - ex 2. 값이 없을 수 있는 경우 (ex. Optional)
    - 함수를 손쉽게 합성할 수 있음 (ex. 비동기 연산들의 합성이 가능)


    ```
    Promise<Customer> customer = // ...
    Promise<byte[]> bytes = customer.map(Customer::getAddress)        // return Promise<Address>
    				.map(Address::Street)                 // return Promise<String>
    				.map((String s) -> s.substring(0, 3)  // return Promise<String>
    				.map(String::getBytes)                // return Promise<byte[]>
    ```

## 모나드

- flatMap을 정의하는 펑터 타입
- map은 리스트 값 내용을 변경, flatMap은 적거나 많은 아이템을 가진 새 list 타입을 반환 (더 강력)

```kotlin
interface Monad<C<_>>: Functor<C<_>> {
  fun <A, B> flatMap(ca: C<A>, fm: (A) -> C<B>): C<B>
}

// Option 타입의 flatMap 함수
fun <T, R> Option<T>.flatMap(fm: (T) -> Option<R>): Option<R> = when (this) {
  Option.None -> Option.None
  is Option.Some -> fm(value)
}

// flatMap을 사용해 map을 재작성
fun <T, R> Option<T>.map(transform: (T) -> R): Option<R> = flatMap { t -> Option.some(transform(t)) }
```

- flatMap의 중첩, flapMap과 map의 조합 → Monadic Comprehensions (13장)

## 어플리커티브

- 래핑된 T 값을 반환하는 순수 함수와 래핑된 람다를 반환하는 ap 함수를 정의하는 타입
- Functor < Applicative < Monad

```kotlin
interface Functor<C<_>> {
  fun <A, B> map(ca: C<A>, transform: (A) -> B): C<B>
}

interface Applicative<C<_>>: Functor<C> {
  // 값을 대수 타입으로 바꾸는 역할 (ex. Mono.just())
  fun <A> pure(a: A): C<A>
  fun <A, B> ap(ca: C<A>, fab: C<(A) -> B>): C<B>
}

interface Monad<C<_>>: Applicative<C> {
  fun <A, B> flatMap(ca: C<A>, fm: (A) -> C<B>): C<B>
}

// Option 타입의 pure 함수 (Option.some의 생성자 역할)
fun <T> Option.Companion.pure(t: T): Option<T> = Option.Some(T)

// Option 타입의 ap 함수
fun <T, R> Option<T>.ap(fab: Option<(T) -> R>): Option<R> = fab.flatMap { f -> map(f) }
```

- map, ap 또한 flatMap으로 할 수 있지만, 가능한 최소한의 힘으로 추상화가 좋음

```kotlin
// flatMap 중첩
val mayBeFive = Option.Some(5)
val mayBeTwo = Option.Some(2)

mayBeFive.flatMap { f ->
	mayBeTwo.flatMap { t ->
		Option.Some(f + t)
	}
}     // Some(value=7)

// flatMap과 map 결합
val mayBeFive = Option.Some(5)
val mayBeTwo = Option.Some(2)

mayBeFive.flatMap { f ->
  mayBeTwo.map { t ->
		f + t
	}
}     // Some(value=7)

// applicative
val mayBeFive = Option.pure(5)
val mayBeTwo = Option.pure(2)

mayBeTwo.ap(mayBeFive.map { f -> {t: Int -> f + t } })     // Some(value=7)
```
  
## 정리
- Functor: 래핑된 값을 꺼내 함수를 적용해서 다시 래핑 (map)
- Applicative: 래핑된 함수에 래핑된 값을 적용 (apply)
- Monad: 래핑된 값을 꺼내 래핑된 결과를 반환하는 함수에 적용 (flatMap)
  
## 참고
- [naver d2: Monad란 무엇인가?](https://www.youtube.com/watch?v=jI4aMyqvpfQ)
- [Functors, Applicatives, And Monads In Pictures](https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html)
- [Kotlin Functors, Applicatives, And Monads in Pictures](https://hackernoon.com/kotlin-functors-applicatives-and-monads-in-pictures-part-1-3-c47a1b1ce251)
- [Kotlin Functors, Applicatives, And Monads in Pictures - 번역](https://medium.com/@lazysoul/kotlin-functors-applicatives-and-monads-in-pictures-part-1-3-a5ac668df83a)
