## Arrow-kt

함수형 코틀린을 추상화 레벨로 정의한 `Arrow-kt` 에 대해 알아보자 :arrow_up: 

## 목차

- [Arrow-kt](#arrow-kt)
- [목차](#목차)
- [배경](#배경)
- [다양한 함수 기법들](#다양한-함수-기법들)
  - [함수 합성(Function Composite)](#함수-합성function-composite)
  - [부분 애플리케이션(Partial Application)](#부분-애플리케이션partial-application)
  - [바인딩(Binding)](#바인딩binding)
  - [리버스(Reverse)](#리버스reverse)
  - [파이프(Pipe)](#파이프pipe)
  - [커링(Curry)](#커링curry)
  - [논리 부정(Logical Complement)](#논리-부정logical-complement)
  - [메모이제이션(Memoization)](#메모이제이션memoization)
  - [부분 함수(Partial Function)](#부분-함수partial-function)
  - [항등 함수(Identity Function)](#항등-함수identity-function)
  - [옵틱스(Optics)](#옵틱스optics)
- [참고 링크](#참고-링크)

## 배경

함수형 프로그래밍에 대한 이해 구조와 추상화 레벨을 맞추고, 공통화된 인터페이스를 사용하기 위해 제작되었다고 생각 🤔  

## 다양한 함수 기법들

함수형 프로그래밍을 이해하기 위해서는 함수를 어떻게 정의하고, 수식을 만들 수 있을지를 생각해야 됩니다.  

따라서 아래 기법들을 이해해보도록 합시다.   

모든 이론의 기초는 [함수](https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98) 에서 시작합니다.  


### 함수 합성(Function Composite)

함수의 합성은 중/고등학교 때 배운 함수와 일치합니다.  

일반적으로 `f(x) o g(x) = f(g(x))` 를 정의하며, `x` 가 `map` 되는 변환과정을 의미한다고 생각하면 쉽습니다.  

`f(x) o g(x) != g(x) o f(x)` 를 만족하니 주의하세요  

```kotlin
import arrow.core.andThen
import arrow.core.compose

// f(x)
private val span: (String) -> String = { "<span>$it</span>" }

// g(x)
private val div: (String) -> String = { "<div>$it</div>" }

fun main() {
    // g(f(x)) = g(x) o f(x)
    val spanAndDiv: (String) -> String = span andThen div

    // f(g(x)) = f(x) o g(x)
    val divAndSpan: (String) -> String = span compose div

    println("<div><span>test</span></div>" == spanAndDiv("test"))
    println("<span><div>test</div></span>" == divAndSpan("test"))
}
```

### 부분 애플리케이션(Partial Application)

쉽게 설명하면, 함수의 인자를 여러개로 받을 수 있는 기존 함수가 있다고 가정합시다.  
`f(x, y, z) = T` 라는 함수가 있다고 가정하면, 인자로 받는 일부분을 미리 고정한다 라고 생각하면 되요.  

바로 코드로 넘어가볼까요?  

```kotlin
import arrow.core.partially2

// f(x, y, z)
private val strong: (String, String, String) -> String = { id, style, body ->
    "<string id=\"$id\" style=\"$style\">$body</strong>"
}

fun main() {
    // g(x, z)
    val redStrong: (String, String) -> String = strong.partially2("font: red")

    // g(x, z) -> f(x, 상수, z)
    println("<string id=\"red_id\" style=\"font: red\">content</strong>" == redStrong("red_id", "content"))
}
```


### 바인딩(Binding)

바인딩은 위에 `Partial Application` 을 이해했으면 정말 간단합니다.  

`Partial Application` 에 부분집합이라고 보시면 됩니다.  

```kotlin
import arrow.core.partially1 as bind

// f(x)
private val footer: (String) -> String = { "<footer>$it</footer>" }

fun main() {
    // g()
    val fixFooter: () -> String = footer.bind("Functional Kotlin")

    // g() -> f(상수)
    println("<footer>Functional Kotlin</footer>" == fixFooter())
}
```

### 리버스(Reverse)

리버스는 쉽게 설명드리면 `함수의 인자에 대한 순서를 바꾼다` 라고 보시면 되고,

저는 개인적으로 설명은 불필요하고 이용가치가 별로 없는 것 같아 생략합니다 


### 파이프(Pipe)

마찬가지로 `함수의 체이닝 기법` 과 동일하며 자주 쓰는 기법이라서 생략합니다.  

수학으로 설명드리면  

```
f(x) o g(x) o z(x) = f(g(z(x)))
```

이며 이를 코드로 나타내면 

```kotlin

x.pipe(z).pipe(g).pipe(f) == f(g(z(x)))
```

입니다 


### 커링(Curry)

커링은 `n 개의 함수 인자를 n 개의 함수 호출 체이닝` 으로 변환하는 것을 의미한다.  

쉽게 말씀드리면 `(A, B) -> R` 을 `(A) -> (B) -> R` 로 변환한다  

어려우니까 바로 코드로 가볼께요

```kotlin
import arrow.core.curried

// f(x, y, z)
private val strong: (String, String, String) -> String = { style, id, body ->
    "<string id=\"$id\" style=\"$style\">$body</strong>"
}

fun main() {
    // f(a(x), b(y), c(z))
    val curriedStrong: (String) -> (String) -> (String) -> String = strong.curried()

    // f(상수, b(y), c(z))
    val greenStrong: (String) -> (String) -> String = curriedStrong("color: green")

    println("<string id=\"red_id\" style=\"color: red\">content</strong>" == curriedStrong("color: red")("red_id")("content"))

    println("<string id=\"green_id\" style=\"color: green\">content</strong>" == greenStrong("green_id")("content"))
}
```

보시면 아시겠지만, 커링의 단점은 반드시 **함수의 파라미터 순서** 에 영향을 받게 됩니다.  

어떻게 해도 첫번째 인자부터 순서대로 입력을 해야되죠  

하지만, 위에서 보신 `Partial Application`의 경우에는 함수의 인자 순서랑 별개로 독립적으로 함수를 구성할 수 있습니다.  

그렇기 때문에 `Curry` 또한 `Partial Application` 의 **부분집합** 이라고 볼 수 있겠죠. 

### 논리 부정(Logical Complement)

정말 간단해서 생략하려고 합니다.  

한줄 요약: `(T) -> Boolean` 입니다 


### 메모이제이션(Memoization)

알고리즘 공부할 때 재귀 함수에 대한 성능향상 방법으로 쓰는 기법이었는데요.  

간단합니다. `f(x) = y` 의 결과를 메모리에 캐싱하는 전략입니다  


```kotlin
import arrow.core.memoize
import kotlin.time.ExperimentalTime
import kotlin.time.measureTimedValue


fun recursiveFib(n: Long): Long {
    return if (n < 2) n else recursiveFib(n - 1) + recursiveFib(n - 2)
}

@OptIn(ExperimentalTime::class)
fun main() {
    var memoizedFib: (Long) -> Long = { it }
    memoizedFib = { n: Long -> if (n < 2) n else memoizedFib(n - 1) + memoizedFib(n - 2) }.memoize()

    val memoizationResult = measureTimedValue { memoizedFib(45) }
    val recursiveResult = measureTimedValue { recursiveFib(45) }
    println("Memoization: ${memoizationResult.duration}")
    println("Recursive: ${recursiveResult.duration}")
}
```

### 부분 함수(Partial Function)

쉽게 설명드리면 함수의 호출 결과를 항상 반환하는 것이 아니라 특정 조건에 의해 만족했을 때만 반환합니다.  

`f(x) = y` 의 구조가 아닌 `Pf(x, y)` 의 구조이다 

함수형 기법의 프로그래밍에서는 if 문을 통한 분기처리가 불가능하기 때문에, 분기처리를 위한 함수라고 보시면 됩니다.

```kotlin
fun main() {
    val upper: (String?) -> String = { it!!.toUpperCase() }
    
    val partialUpper: PartialFunction<String?, String> = PartialFunction(definedAt = { it != null}, f = upper)
}
```

### 항등 함수(Identity Function)

마찬가지로 한줄 요약이 가능합니다.  

한줄 요약: `f(x) = x`

### 옵틱스(Optics)

[공식 문서](https://arrow-kt.io/docs/optics/)에도 정확하게 정의가 나타나 있습니다  

불변 데이터를 변환하거나 연산하는데에 있어서 추상화된 레벨  

Optics 의 종류중의 하나인 `Lens` 를 예시로 설명해보겠습니다.  

```kotlin
import arrow.optics.Lens

data class Product(val name: String)
data class OrderItem(val quantity: Long, val product: Product)
data class Order(val purchaserName: String, val orderItem: OrderItem)

// 이러한 것은 arrow kt 에서 지원해주는 kapt 기능을 통하여 자동생성이 가능하다. @optics 어노테이션 기반
private val orderOrderItem: Lens<Order, OrderItem> = Lens(
    get = { it.orderItem },
    set = { order, orderItem -> order.copy(orderItem = orderItem) }
)

private val orderItemProduct: Lens<OrderItem, Product> = Lens(
    get = { it.product },
    set = { orderItem, product -> orderItem.copy(product = product) }
)

private val productName: Lens<Product, String> = Lens(
    get = { it.name },
    set = { product, name -> product.copy(name = name) }
)


fun main() {
    val order = Order(
        purchaserName = "customer",
        orderItem = OrderItem(
            quantity = 1L,
            product = Product(name = "productA")
        )
    )

    val order2 = order.copy(
        orderItem = order.orderItem.copy(
            product = order.orderItem.product.copy(
                name = "productB"
            )
        )
    )

    val orderCopyOnlyProductName: Lens<Order, String> = orderOrderItem compose orderItemProduct compose productName
    val order3 = orderCopyOnlyProductName.modify(order) { "productB" }

    println(order2.orderItem.product.name == order3.orderItem.product.name)
}
```


## 참고 링크

- [Arrow-kt-core](https://arrow-kt.io/docs/core/)
- [KotlinConf-2018-Functional-Programming-In-Kotlin-with-Arrow](https://www.youtube.com/watch?v=VOZZTSuDMFE)
- [Arrow-kt-Optics](https://arrow-kt.io/docs/optics/)