## Arrow-kt

í•¨ìˆ˜í˜• ì½”í‹€ë¦°ì„ ì¶”ìƒí™” ë ˆë²¨ë¡œ ì •ì˜í•œ `Arrow-kt` ì— ëŒ€í•´ ì•Œì•„ë³´ì :arrow_up: 

## ëª©ì°¨

- [Arrow-kt](#arrow-kt)
- [ëª©ì°¨](#ëª©ì°¨)
- [ë°°ê²½](#ë°°ê²½)
- [ë‹¤ì–‘í•œ í•¨ìˆ˜ ê¸°ë²•ë“¤](#ë‹¤ì–‘í•œ-í•¨ìˆ˜-ê¸°ë²•ë“¤)
  - [í•¨ìˆ˜ í•©ì„±(Function Composite)](#í•¨ìˆ˜-í•©ì„±function-composite)
  - [ë¶€ë¶„ ì• í”Œë¦¬ì¼€ì´ì…˜(Partial Application)](#ë¶€ë¶„-ì• í”Œë¦¬ì¼€ì´ì…˜partial-application)
  - [ë°”ì¸ë”©(Binding)](#ë°”ì¸ë”©binding)
  - [ë¦¬ë²„ìŠ¤(Reverse)](#ë¦¬ë²„ìŠ¤reverse)
  - [íŒŒì´í”„(Pipe)](#íŒŒì´í”„pipe)
  - [ì»¤ë§(Curry)](#ì»¤ë§curry)
  - [ë…¼ë¦¬ ë¶€ì •(Logical Complement)](#ë…¼ë¦¬-ë¶€ì •logical-complement)
  - [ë©”ëª¨ì´ì œì´ì…˜(Memoization)](#ë©”ëª¨ì´ì œì´ì…˜memoization)
  - [ë¶€ë¶„ í•¨ìˆ˜(Partial Function)](#ë¶€ë¶„-í•¨ìˆ˜partial-function)
  - [í•­ë“± í•¨ìˆ˜(Identity Function)](#í•­ë“±-í•¨ìˆ˜identity-function)
  - [ì˜µí‹±ìŠ¤(Optics)](#ì˜µí‹±ìŠ¤optics)
- [ì°¸ê³  ë§í¬](#ì°¸ê³ -ë§í¬)

## ë°°ê²½

í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì— ëŒ€í•œ ì´í•´ êµ¬ì¡°ì™€ ì¶”ìƒí™” ë ˆë²¨ì„ ë§ì¶”ê³ , ê³µí†µí™”ëœ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ì œì‘ë˜ì—ˆë‹¤ê³  ìƒê° ğŸ¤”  

## ë‹¤ì–‘í•œ í•¨ìˆ˜ ê¸°ë²•ë“¤

í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì„ ì´í•´í•˜ê¸° ìœ„í•´ì„œëŠ” í•¨ìˆ˜ë¥¼ ì–´ë–»ê²Œ ì •ì˜í•˜ê³ , ìˆ˜ì‹ì„ ë§Œë“¤ ìˆ˜ ìˆì„ì§€ë¥¼ ìƒê°í•´ì•¼ ë©ë‹ˆë‹¤.  

ë”°ë¼ì„œ ì•„ë˜ ê¸°ë²•ë“¤ì„ ì´í•´í•´ë³´ë„ë¡ í•©ì‹œë‹¤.   

ëª¨ë“  ì´ë¡ ì˜ ê¸°ì´ˆëŠ” [í•¨ìˆ˜](https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98) ì—ì„œ ì‹œì‘í•©ë‹ˆë‹¤.  


### í•¨ìˆ˜ í•©ì„±(Function Composite)

í•¨ìˆ˜ì˜ í•©ì„±ì€ ì¤‘/ê³ ë“±í•™êµ ë•Œ ë°°ìš´ í•¨ìˆ˜ì™€ ì¼ì¹˜í•©ë‹ˆë‹¤.  

ì¼ë°˜ì ìœ¼ë¡œ `f(x) o g(x) = f(g(x))` ë¥¼ ì •ì˜í•˜ë©°, `x` ê°€ `map` ë˜ëŠ” ë³€í™˜ê³¼ì •ì„ ì˜ë¯¸í•œë‹¤ê³  ìƒê°í•˜ë©´ ì‰½ìŠµë‹ˆë‹¤.  

`f(x) o g(x) != g(x) o f(x)` ë¥¼ ë§Œì¡±í•˜ë‹ˆ ì£¼ì˜í•˜ì„¸ìš”  

```kotlin
import arrow.core.andThen
import arrow.core.compose

// f(x)
private val span: (String) -> String = { "<span>$it</span>" }

// g(x)
private val div: (String) -> String = { "<div>$it</div>" }

fun main() {
    // g(f(x)) = g(x) o f(x)
    val spanAndDiv: (String) -> String = span andThen div

    // f(g(x)) = f(x) o g(x)
    val divAndSpan: (String) -> String = span compose div

    println("<div><span>test</span></div>" == spanAndDiv("test"))
    println("<span><div>test</div></span>" == divAndSpan("test"))
}
```

### ë¶€ë¶„ ì• í”Œë¦¬ì¼€ì´ì…˜(Partial Application)

ì‰½ê²Œ ì„¤ëª…í•˜ë©´, í•¨ìˆ˜ì˜ ì¸ìë¥¼ ì—¬ëŸ¬ê°œë¡œ ë°›ì„ ìˆ˜ ìˆëŠ” ê¸°ì¡´ í•¨ìˆ˜ê°€ ìˆë‹¤ê³  ê°€ì •í•©ì‹œë‹¤.  
`f(x, y, z) = T` ë¼ëŠ” í•¨ìˆ˜ê°€ ìˆë‹¤ê³  ê°€ì •í•˜ë©´, ì¸ìë¡œ ë°›ëŠ” ì¼ë¶€ë¶„ì„ ë¯¸ë¦¬ ê³ ì •í•œë‹¤ ë¼ê³  ìƒê°í•˜ë©´ ë˜ìš”.  

ë°”ë¡œ ì½”ë“œë¡œ ë„˜ì–´ê°€ë³¼ê¹Œìš”?  

```kotlin
import arrow.core.partially2

// f(x, y, z)
private val strong: (String, String, String) -> String = { id, style, body ->
    "<string id=\"$id\" style=\"$style\">$body</strong>"
}

fun main() {
    // g(x, z)
    val redStrong: (String, String) -> String = strong.partially2("font: red")

    // g(x, z) -> f(x, ìƒìˆ˜, z)
    println("<string id=\"red_id\" style=\"font: red\">content</strong>" == redStrong("red_id", "content"))
}
```


### ë°”ì¸ë”©(Binding)

ë°”ì¸ë”©ì€ ìœ„ì— `Partial Application` ì„ ì´í•´í–ˆìœ¼ë©´ ì •ë§ ê°„ë‹¨í•©ë‹ˆë‹¤.  

`Partial Application` ì— ë¶€ë¶„ì§‘í•©ì´ë¼ê³  ë³´ì‹œë©´ ë©ë‹ˆë‹¤.  

```kotlin
import arrow.core.partially1 as bind

// f(x)
private val footer: (String) -> String = { "<footer>$it</footer>" }

fun main() {
    // g()
    val fixFooter: () -> String = footer.bind("Functional Kotlin")

    // g() -> f(ìƒìˆ˜)
    println("<footer>Functional Kotlin</footer>" == fixFooter())
}
```

### ë¦¬ë²„ìŠ¤(Reverse)

ë¦¬ë²„ìŠ¤ëŠ” ì‰½ê²Œ ì„¤ëª…ë“œë¦¬ë©´ `í•¨ìˆ˜ì˜ ì¸ìì— ëŒ€í•œ ìˆœì„œë¥¼ ë°”ê¾¼ë‹¤` ë¼ê³  ë³´ì‹œë©´ ë˜ê³ ,

ì €ëŠ” ê°œì¸ì ìœ¼ë¡œ ì„¤ëª…ì€ ë¶ˆí•„ìš”í•˜ê³  ì´ìš©ê°€ì¹˜ê°€ ë³„ë¡œ ì—†ëŠ” ê²ƒ ê°™ì•„ ìƒëµí•©ë‹ˆë‹¤ 


### íŒŒì´í”„(Pipe)

ë§ˆì°¬ê°€ì§€ë¡œ `í•¨ìˆ˜ì˜ ì²´ì´ë‹ ê¸°ë²•` ê³¼ ë™ì¼í•˜ë©° ìì£¼ ì“°ëŠ” ê¸°ë²•ì´ë¼ì„œ ìƒëµí•©ë‹ˆë‹¤.  

ìˆ˜í•™ìœ¼ë¡œ ì„¤ëª…ë“œë¦¬ë©´  

```
f(x) o g(x) o z(x) = f(g(z(x)))
```

ì´ë©° ì´ë¥¼ ì½”ë“œë¡œ ë‚˜íƒ€ë‚´ë©´ 

```kotlin

x.pipe(z).pipe(g).pipe(f) == f(g(z(x)))
```

ì…ë‹ˆë‹¤ 


### ì»¤ë§(Curry)

ì»¤ë§ì€ `n ê°œì˜ í•¨ìˆ˜ ì¸ìë¥¼ n ê°œì˜ í•¨ìˆ˜ í˜¸ì¶œ ì²´ì´ë‹` ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤.  

ì‰½ê²Œ ë§ì”€ë“œë¦¬ë©´ `(A, B) -> R` ì„ `(A) -> (B) -> R` ë¡œ ë³€í™˜í•œë‹¤  

ì–´ë ¤ìš°ë‹ˆê¹Œ ë°”ë¡œ ì½”ë“œë¡œ ê°€ë³¼ê»˜ìš”

```kotlin
import arrow.core.curried

// f(x, y, z)
private val strong: (String, String, String) -> String = { style, id, body ->
    "<string id=\"$id\" style=\"$style\">$body</strong>"
}

fun main() {
    // f(a(x), b(y), c(z))
    val curriedStrong: (String) -> (String) -> (String) -> String = strong.curried()

    // f(ìƒìˆ˜, b(y), c(z))
    val greenStrong: (String) -> (String) -> String = curriedStrong("color: green")

    println("<string id=\"red_id\" style=\"color: red\">content</strong>" == curriedStrong("color: red")("red_id")("content"))

    println("<string id=\"green_id\" style=\"color: green\">content</strong>" == greenStrong("green_id")("content"))
}
```

ë³´ì‹œë©´ ì•„ì‹œê² ì§€ë§Œ, ì»¤ë§ì˜ ë‹¨ì ì€ ë°˜ë“œì‹œ **í•¨ìˆ˜ì˜ íŒŒë¼ë¯¸í„° ìˆœì„œ** ì— ì˜í–¥ì„ ë°›ê²Œ ë©ë‹ˆë‹¤.  

ì–´ë–»ê²Œ í•´ë„ ì²«ë²ˆì§¸ ì¸ìë¶€í„° ìˆœì„œëŒ€ë¡œ ì…ë ¥ì„ í•´ì•¼ë˜ì£   

í•˜ì§€ë§Œ, ìœ„ì—ì„œ ë³´ì‹  `Partial Application`ì˜ ê²½ìš°ì—ëŠ” í•¨ìˆ˜ì˜ ì¸ì ìˆœì„œë‘ ë³„ê°œë¡œ ë…ë¦½ì ìœ¼ë¡œ í•¨ìˆ˜ë¥¼ êµ¬ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

ê·¸ë ‡ê¸° ë•Œë¬¸ì— `Curry` ë˜í•œ `Partial Application` ì˜ **ë¶€ë¶„ì§‘í•©** ì´ë¼ê³  ë³¼ ìˆ˜ ìˆê² ì£ . 

### ë…¼ë¦¬ ë¶€ì •(Logical Complement)

ì •ë§ ê°„ë‹¨í•´ì„œ ìƒëµí•˜ë ¤ê³  í•©ë‹ˆë‹¤.  

í•œì¤„ ìš”ì•½: `(T) -> Boolean` ì…ë‹ˆë‹¤ 


### ë©”ëª¨ì´ì œì´ì…˜(Memoization)

ì•Œê³ ë¦¬ì¦˜ ê³µë¶€í•  ë•Œ ì¬ê·€ í•¨ìˆ˜ì— ëŒ€í•œ ì„±ëŠ¥í–¥ìƒ ë°©ë²•ìœ¼ë¡œ ì“°ëŠ” ê¸°ë²•ì´ì—ˆëŠ”ë°ìš”.  

ê°„ë‹¨í•©ë‹ˆë‹¤. `f(x) = y` ì˜ ê²°ê³¼ë¥¼ ë©”ëª¨ë¦¬ì— ìºì‹±í•˜ëŠ” ì „ëµì…ë‹ˆë‹¤  


```kotlin
import arrow.core.memoize
import kotlin.time.ExperimentalTime
import kotlin.time.measureTimedValue


fun recursiveFib(n: Long): Long {
    return if (n < 2) n else recursiveFib(n - 1) + recursiveFib(n - 2)
}

@OptIn(ExperimentalTime::class)
fun main() {
    var memoizedFib: (Long) -> Long = { it }
    memoizedFib = { n: Long -> if (n < 2) n else memoizedFib(n - 1) + memoizedFib(n - 2) }.memoize()

    val memoizationResult = measureTimedValue { memoizedFib(45) }
    val recursiveResult = measureTimedValue { recursiveFib(45) }
    println("Memoization: ${memoizationResult.duration}")
    println("Recursive: ${recursiveResult.duration}")
}
```

### ë¶€ë¶„ í•¨ìˆ˜(Partial Function)

ì‰½ê²Œ ì„¤ëª…ë“œë¦¬ë©´ í•¨ìˆ˜ì˜ í˜¸ì¶œ ê²°ê³¼ë¥¼ í•­ìƒ ë°˜í™˜í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ íŠ¹ì • ì¡°ê±´ì— ì˜í•´ ë§Œì¡±í–ˆì„ ë•Œë§Œ ë°˜í™˜í•©ë‹ˆë‹¤.  

`f(x) = y` ì˜ êµ¬ì¡°ê°€ ì•„ë‹Œ `Pf(x, y)` ì˜ êµ¬ì¡°ì´ë‹¤ 

í•¨ìˆ˜í˜• ê¸°ë²•ì˜ í”„ë¡œê·¸ë˜ë°ì—ì„œëŠ” if ë¬¸ì„ í†µí•œ ë¶„ê¸°ì²˜ë¦¬ê°€ ë¶ˆê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì—, ë¶„ê¸°ì²˜ë¦¬ë¥¼ ìœ„í•œ í•¨ìˆ˜ë¼ê³  ë³´ì‹œë©´ ë©ë‹ˆë‹¤.

```kotlin
fun main() {
    val upper: (String?) -> String = { it!!.toUpperCase() }
    
    val partialUpper: PartialFunction<String?, String> = PartialFunction(definedAt = { it != null}, f = upper)
}
```

### í•­ë“± í•¨ìˆ˜(Identity Function)

ë§ˆì°¬ê°€ì§€ë¡œ í•œì¤„ ìš”ì•½ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.  

í•œì¤„ ìš”ì•½: `f(x) = x`

### ì˜µí‹±ìŠ¤(Optics)

[ê³µì‹ ë¬¸ì„œ](https://arrow-kt.io/docs/optics/)ì—ë„ ì •í™•í•˜ê²Œ ì •ì˜ê°€ ë‚˜íƒ€ë‚˜ ìˆìŠµë‹ˆë‹¤  

ë¶ˆë³€ ë°ì´í„°ë¥¼ ë³€í™˜í•˜ê±°ë‚˜ ì—°ì‚°í•˜ëŠ”ë°ì— ìˆì–´ì„œ ì¶”ìƒí™”ëœ ë ˆë²¨  

Optics ì˜ ì¢…ë¥˜ì¤‘ì˜ í•˜ë‚˜ì¸ `Lens` ë¥¼ ì˜ˆì‹œë¡œ ì„¤ëª…í•´ë³´ê² ìŠµë‹ˆë‹¤.  

```kotlin
import arrow.optics.Lens

data class Product(val name: String)
data class OrderItem(val quantity: Long, val product: Product)
data class Order(val purchaserName: String, val orderItem: OrderItem)

// ì´ëŸ¬í•œ ê²ƒì€ arrow kt ì—ì„œ ì§€ì›í•´ì£¼ëŠ” kapt ê¸°ëŠ¥ì„ í†µí•˜ì—¬ ìë™ìƒì„±ì´ ê°€ëŠ¥í•˜ë‹¤. @optics ì–´ë…¸í…Œì´ì…˜ ê¸°ë°˜
private val orderOrderItem: Lens<Order, OrderItem> = Lens(
    get = { it.orderItem },
    set = { order, orderItem -> order.copy(orderItem = orderItem) }
)

private val orderItemProduct: Lens<OrderItem, Product> = Lens(
    get = { it.product },
    set = { orderItem, product -> orderItem.copy(product = product) }
)

private val productName: Lens<Product, String> = Lens(
    get = { it.name },
    set = { product, name -> product.copy(name = name) }
)


fun main() {
    val order = Order(
        purchaserName = "customer",
        orderItem = OrderItem(
            quantity = 1L,
            product = Product(name = "productA")
        )
    )

    val order2 = order.copy(
        orderItem = order.orderItem.copy(
            product = order.orderItem.product.copy(
                name = "productB"
            )
        )
    )

    val orderCopyOnlyProductName: Lens<Order, String> = orderOrderItem compose orderItemProduct compose productName
    val order3 = orderCopyOnlyProductName.modify(order) { "productB" }

    println(order2.orderItem.product.name == order3.orderItem.product.name)
}
```


## ì°¸ê³  ë§í¬

- [Arrow-kt-core](https://arrow-kt.io/docs/core/)
- [KotlinConf-2018-Functional-Programming-In-Kotlin-with-Arrow](https://www.youtube.com/watch?v=VOZZTSuDMFE)
- [Arrow-kt-Optics](https://arrow-kt.io/docs/optics/)