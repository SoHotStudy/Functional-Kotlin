# 9. Functional Programming and Reactive Programming

## Combining FP with OOP
### FP vs OOP
- side effect
- state
- functional in the small, object-oriendted in the large
  - OOP: higher level, class, interface
  - FP: lower level, method, function


## Functional reactive programming
### Reactive programming
- asynchronous
- propagation of change
- to all the interested parties(end users, components, sub-parts, other program)

### Reactive Manifesto (https://www.reactivemanifesto.org/)
- Responsive: rapid, consistent response time
- Resilient: failure > replication, containment, isolation, delegation
- Elastic: varying workloads, cost-effective way on commodity hardware and software platform
- Message-driven: boundary between components

## Functional reactive frameworks for Kotlin
- RxKotlin (https://github.com/ReactiveX/RxKotlin)
- Reactor-Kotlin (https://godekdls.github.io/Reactor%20Core/kotlinsupport/)
- Redux-Kotlin (https://github.com/reduxkotlin/redux-kotlin)
- Java frameworks(RxJava, ReactiveX)

## RxKotlin
- function composition
- avoid global state, side effect
- observer pattern: producer/consumer. (https://refactoring.guru/design-patterns/observer)
- Reactive Streams

### Comparing the Pull mechanism with the RxJava Push mechanism
```
fun main(args: Array<String>) { 
    var list:List<Any> = listOf(1, "Two", 3, "Four", "Five", 5.5f) // 1 
    var iterator = list.iterator() // 2 
    while (iterator.hasNext()) { // 3 
        println(iterator.next()) // Prints each element 4 
    } 
} 
```

```
fun main(args: Array<String>) { 
    var list = listOf(1, "Two", 3, "Four", "Five", 5.5f) // 1 
    var observable = list.toObservable(); 
 
    observable.subscribeBy(  // named arguments for lambda Subscribers 
            onNext = { println(it) }, 
            onError =  { it.printStackTrace() }, 
            onComplete = { println("Done!") } 
    ) 
} 
```

### Observables
![observables](https://user-images.githubusercontent.com/26020579/167506331-cdd5c648-6d72-447e-a384-c21d0b849f79.png)
```
fun main(args: Array<String>) { 
 
    val observer = object :Observer<Any>{//1 
    override fun onComplete() {//2 
        println("All Completed") 
    } 
 
        override fun onNext(item: Any) {//3 
            println("Next $item") 
        } 
 
        override fun onError(e: Throwable) {//4 
            println("Error Occured $e") 
        } 
 
        override fun onSubscribe(d: Disposable) {//5 
            println("Subscribed to $d") 
        } 
    } 
 
    val observable = listOf(1, "Two", 3, "Four", "Five", 5.5f).toObservable() //6 
 
    observable.subscribe(observer)//7 
 
    val observableOnList = Observable.just(listOf("One", 2, "Three", "Four", 4.5, "Five", 6.0f), 
            listOf("List with 1 Item"), 
            listOf(1,2,3))//8 
 
 
 
    observableOnList.subscribe(observer)//9 
} 
```

#### Observable.create
```
fun main(args: Array<String>) { 
 
    val observer: Observer<String> = object : Observer<String> { 
        override fun onComplete() { 
            println("All Completed") 
        } 
 
        override fun onNext(item: String) { 
            println("Next $item") 
        } 
 
        override fun onError(e: Throwable) { 
            println("Error Occured => ${e.message}") 
        } 
 
        override fun onSubscribe(d: Disposable) { 
            println("New Subscription ") 
        } 
    }//Create Observer 
 
    val observable:Observable<String> = Observable.create<String> {//1 
        it.onNext("Emitted 1") 
        it.onNext("Emitted 2") 
        it.onNext("Emitted 3") 
        it.onNext("Emitted 4") 
        it.onComplete() 
    } 
 
    observable.subscribe(observer) 
 
    val observable2:Observable<String> = Observable.create<String> {//2 
        it.onNext("Emitted 1") 
        it.onNext("Emitted 2") 
        it.onError(Exception("My Exception")) 
    } 
 
    observable2.subscribe(observer) 
} 
```

#### Observable.from
```
fun main(args: Array<String>) { 
 
    val observer: Observer<String> = object : Observer<String> { 
        override fun onComplete() { 
            println("Completed") 
        } 
 
        override fun onNext(item: String) { 
            println("Received-> $item") 
        } 
 
        override fun onError(e: Throwable) { 
            println("Error Occured => ${e.message}") 
        } 
 
        override fun onSubscribe(d: Disposable) { 
            println("Subscription") 
        } 
    }//Create Observer 
 
    val list = listOf("Str 1","Str 2","Str 3","Str 4") 
    val observableFromIterable: Observable<String> = Observable.fromIterable(list)//1 
    observableFromIterable.subscribe(observer) 
 
 
    val callable = object : Callable<String> { 
        override fun call(): String { 
            return "I'm From Callable" 
        } 
 
    } 
    val observableFromCallable:Observable<String> = Observable.fromCallable(callable)//2 
    observableFromCallable.subscribe(observer) 
 
    val future:Future<String> = object : Future<String> { 
        val retStr = "I'm from Future" 
 
        override fun get() = retStr 
 
        override fun get(timeout: Long, unit: TimeUnit?)  = retStr 
 
        override fun isDone(): Boolean = true 
 
        override fun isCancelled(): Boolean = false 
 
        override fun cancel(mayInterruptIfRunning: Boolean): Boolean = false 
 
    } 
    val observableFromFuture:Observable<String> = Observable.fromFuture(future)//3 
    observableFromFuture.subscribe(observer) 
} 
```

#### Iterator<T>.toObservable
```
fun main(args: Array<String>) { 
    val observer: Observer<String> = object : Observer<String> { 
        override fun onComplete() { 
            println("Completed") 
        } 
 
        override fun onNext(item: String) { 
            println("Received-> $item") 
        } 
 
        override fun onError(e: Throwable) { 
            println("Error Occured => ${e.message}") 
        } 
 
        override fun onSubscribe(d: Disposable) { 
            println("Subscription") 
        } 
    }//Create Observer 
    val list:List<String> = listOf("Str 1","Str 2","Str 3","Str 4") 
 
    val observable: Observable<String> = list.toObservable() 
 
    observable.subscribe(observer) 
 
}   
```
```
fun <T : Any> Iterator<T>.toObservable(): Observable<T> = toIterable().toObservable() 
fun <T : Any> Iterable<T>.toObservable(): Observable<T> = Observable.fromIterable(this) 
fun <T : Any> Sequence<T>.toObservable(): Observable<T> = asIterable().toObservable() 
 
fun <T : Any> Iterable<Observable<out T>>.merge(): Observable<T> = Observable.merge(this.toObservable()) 
fun <T : Any> Iterable<Observable<out T>>.mergeDelayError(): Observable<T> = Observable.mergeDelayError(this.toObservable())   
```  
  
#### Subscribing and disposing
```
fun main(args: Array<String>) { 
    val observable = Observable.range(1,5)//1 
 
    observable.subscribe({//2 
        //onNext method 
        println("Next-> $it") 
    },{ 
        //onError Method 
        println("Error=> ${it.message}") 
    },{ 
        //onComplete Method 
        println("Done") 
    }) 
 
    val observer: Observer<Int> = object : Observer<Int> {//3 
    override fun onComplete() { 
        println("All Completed") 
    } 
 
        override fun onNext(item: Int) { 
            println("Next-> $item") 
        } 
 
        override fun onError(e: Throwable) { 
            println("Error Occurred=> ${e.message}") 
        } 
 
        override fun onSubscribe(d: Disposable) { 
            println("New Subscription ") 
        } 
    } 
 
    observable.subscribe(observer) 
}   
```  

```
fun main(args: Array<String>) { 
 
    val observale = Observable.interval(100, TimeUnit.MILLISECONDS)//1 
    val observer = object : Observer<Long> { 
 
        lateinit var disposable: Disposable//2 
 
        override fun onSubscribe(d: Disposable) { 
            disposable = d//3 
        } 
 
        override fun onNext(item: Long) { 
            println("Received $item") 
            if (item >= 10 && !disposable.isDisposed) {//4 
                disposable.dispose()//5 
                println("Disposed") 
            } 
        } 
 
        override fun onError(e: Throwable) { 
            println("Error ${e.message}") 
        } 
 
        override fun onComplete() { 
            println("Complete") 
        } 
 
    } 
    runBlocking { 
        observale.subscribe(observer) 
        delay(1500)//6 
    } 
}   
```  
  
```
interface Disposable { 
  /** 
 * Dispose the resource, the operation should be idempotent. 
 */ 
  fun dispose() 
  /** 
 * Returns true if this resource has been disposed. 
 * @return true if this resource has been disposed 
 */ 
  val isDisposed:Boolean 
}   
```  
