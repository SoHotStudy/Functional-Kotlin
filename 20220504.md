
# 7장 코틀린을 사용한 비동기 프로그래밍
### [코루틴](https://ko.wikipedia.org/wiki/%EC%BD%94%EB%A3%A8%ED%8B%B4)
* 책에서는 경량 스레드로 정의하고 있으나 틀린 말
* 코루틴(coroutine)은 루틴의 일종으로서, 협동 루틴이라 할 수 있다(코루틴의 "Co"는 with 또는 togather를 뜻한다). 상호 연계 프로그램을 일컫는다고도 표현가능하다. 루틴과 서브 루틴은 서로 비대칭적인 관계이지만, 코루틴들은 완전히 대칭적인, 즉 서로가 서로를 호출하는 관계이다. 코루틴들에서는 무엇이 무엇의 서브루틴인지를 구분하는 것이 불가능하다. 코루틴 A와 B가 있다고 할 때, A를 프로그래밍 할 때는 B를 A의 서브루틴으로 생각한다. 그러나 B를 프로그래밍할 때는 A가 B의 서브루틴이라고 생각한다. 어떠한 코루틴이 발동될 때마다 해당 코루틴은 이전에 자신의 실행이 마지막으로 중단되었던 지점 다음의 장소에서 실행을 재개한다.[1]

### JVM 스레드
JVM 에서 비동기 동시 어플리케이션의 빌딩 블록을 의미하며 OS 의 네이티브 스레드를 생성하게 된다 - [project loom](https://wiki.openjdk.java.net/display/loom/Main) 에서 코루틴과 비슷한 가상 스레드가 생길 예정

#### JVM 스레드 단점
비용이 크고 생성/제거(가비지컬렉션)/컨텍스트 스위치에 CPU, 메모리 자원을 크게 소모한다

스레드를 많이 생성할 경우 OOM 이 발생할 가능성이 크다

### 동기/비동기 구현 비교

||코드복잡성|리소스 소비
|---|---|---
|동기|낮음|많고 느림
|콜백|매우 높은 어댑터 필요, 읽기 힘듦|자원 소비가 높음 Executor 를 사용하면 괜찮긴 하지만 복잡도가 올라감
|퓨처|중간, 그러나 여전히 어려움|리소스 소비가 높지만 Executor 로 조절 가능
|프로미스|프로미스 스타일(then, success)를 사용하면 중간, 퓨처 스타일(get)을 사용하면 코루틴과 비슷하게 사용 가능|소비는 매우 높고 최고의 퍼포먼스를 갖지만 코드변경 없이 미세 조정 가능
|코루틴|복잡도 낮음|리소스 소비 낮고 최상의 성능

* 코버넌트를 사용하면 JS Promise 랑 비슷하게 사용 가능

### 채널
* 보내는 코루틴과 받는 코루틴을 분리할 수 있고 버퍼를 적용해 Back pressure 도 구현할 수 있는 코루틴 처리 방법
![image](https://t1.daumcdn.net/cfile/tistory/99DC304E5F7D436826)

채널 버퍼의 타입들

Channel은 여러 버퍼 타입을 통해 Coroutine과의 커뮤니케이션의 유연성을 제공한다.


1. Rendezvous (Unbuffered)

![image](https://t1.daumcdn.net/cfile/tistory/9937FC445F7D47B026)

```kotlin
val channel = Channel<Menu>(capacity = Channel.RENDEZVOUS)
```

랑데부 = 집합, 만나기로한 약속.

특별한 채널 버퍼를 설정하지 않을 시 이 타입이 기본적으로 설정된다. Rendezvous는 버퍼가 없다. 이것이 위 예제코드에서 본 것처럼 수신측 Coroutine과 송신측 Coroutine이 모두 가능한 상태로 "모일때까지" suspend 되는 이유다.


2. Conflated

![image](https://t1.daumcdn.net/cfile/tistory/9905F5385F7D50892C)

```kotlin
val channel = Channel<Menu>(capacity = Channel.CONFLATED)
```

Conflate의 뜻은 "융합하다", "하나로 합치다"다.

이렇게하면 크기가 1인 고정 버퍼가 있는 채널이 생성된다. 만약에 수신하는 Coroutine이 송신하는 Coroutine을 따라잡지 못했다면, 송신하는 쪽은 새로운 값을 버퍼의 마지막 아이템에 덮어씌운다. 수신 Coroutine이 다음 값을 받을 차례가 되면, 송신 Coroutine이 보낸 마지막 값을 받는다. 즉 송신하는 쪽은 수신측 Coroutine이 가능할때까지 기다리는게 없다는 말이다. 수신측 Coroutine은 채널 버퍼에 값이 올때까지 suspend 된다.

3. Buffered

![image](https://t1.daumcdn.net/cfile/tistory/99DF7A4E5F7D530C2F)

```kotlin
val channel = Channel<Menu>(capacity = 10)
```

이 모드는 고정된 크기의 버퍼를 생성합니다. 버퍼는 Array 형식이다.

송신 Coroutine은 버퍼가 꽉 차있으면 새로운 값을 보내는 걸 중단한다. 수신 Coroutine은 버퍼가 빌때까지 계속해서 꺼내서 수행한다.

4. Unlimited

![image](https://t1.daumcdn.net/cfile/tistory/99C425465F7D563131)

```kotlin
val channel = Channel<Menu>(capacity = Channel.UNLIMITED)
```
이 모드는 이름처럼 제한 없는 크기의 버퍼를 가진다. 버퍼는 LinkedList 형식이다.

만약에 버퍼가 소비되지 않았다면 메모리가 ...힘들어할때까지 계속해서 아이템을 착착 채운다. 결국엔 OutOfMemeoryException을 일으키게 된다.

송신 Coroutine은 suspend 하지않지만, 수신 Coroutine은 버퍼가 비면 suspend 된다.

#### 채널 파이프라인

채널이 있을 때 파이프라인 패턴을 가질 수 있다.

channel A -> channel B 로 변환해서 처리 가능

```kotlin
fun <T, R> channelTransform(context: CoroutineContext, from: ReceiveChannel<T>): SendChannel<R> = produce(context) {
    for (msg: R in from) {
        send(msg)
    }
}
```

### 변경 가능한 상태 관리

* 컨텍스트 전환
  * withContext 사용
* 스레드 안전 구조체
  * AtomicXXX 사용
* 뮤텍스 사용
  * Mutex.withLock 
* 액터
  * actor<T> { ... } 코루틴 빌더 메소드로 생성
  * channel 필드를 내부에 가지고 있음
  * 반환은 SendChannel<T> 를 반환
  * 생성된 액터에 send 메시지를 보내면 상태를 저장하고 스레드 안전하게 처리 가능
```kotlin
fun CoroutineScope.counterActor() = actor<CounterMsg> {
   var counter = 0 // actor state
   for (msg in channel) { // iterate over incoming messages
       when (msg) {
           is IncCounter -> counter++
           is GetCounter -> msg.response.complete(counter)
       }
   }
}
 
fun main() = runBlocking<Unit> {
    val counter = counterActor() // create the actor
    withContext(Dispatchers.Default) {
        massiveRun {
            counter.send(IncCounter)
        }
    }
    // send a message to get a counter value from an actor
    val response = CompletableDeferred<Int>()
    counter.send(GetCounter(response))
    println("Counter = ${response.await()}")
    counter.close() // shutdown the actor
} 
```

# 8장 코틀린의 컬렉션과 데이터 작업

코틀린의 컬렉션 프레임워크는 자바보다 훨씬 기능적

### 컬렉션 소개
컬렉션 프레임워크는 다음과 같은 공통 데이터 관련 작업 그룹을 수행하기 위한 통합 아키텍쳐를 제공하는 클래스와 인터페이스 세트다
* 검색
* 정렬
* 삽입
* 삭제
* 조작

### 장점
가변/불변을 구분할 수 있는 인터페이스 구조
![image](https://user-images.githubusercontent.com/5905201/166584414-8474298b-5d9d-47cd-9ba5-2c8b7b1f4ea1.png)
* 지난번 스터디에서처럼 MustableXXX 로 필드를 객체 내부에 private 으로 생성하고 외부 오픈시 Immutable 형태로 노출 가능

### 특수한 컬렉션 동작들

* Map
  * to
  * mapOf( 123 to 456 )
  * map["key"]
    * operator 를 이용한 접근
* List
  * list[123]
    * operator 를 이용한 접근
* Set
  * set["key"]
    * operator 를 이용한 접근
* 데이터 조작 함수
  * map, filter, flatMap - 우리가 알고 있는 동작
  * drop - n 번째까지 데이터를 삭제한 새 컬렉션을 생성
  * take - n 번째 까지 데이터만 포함된 새 컬렉션을 생성
  * zip - 압축 한다는 의미이지만 와 닿지는 않고 실제로는 두 컬렉션을 하나로 합쳐서 컬렉션의 pair 컬렉션을 생성
    * 수행한 컬렉션 갯수 기준으로 새 컬렉션 생성

```kotlin
val list = listOf(1,2,3,4,5)
val list2 = listOf("item1", "item2", "item3", "item4", "item5", "item6")

println(list1.zip(list2)) // [(1, item1), (2, item3), ..., (5, item5)]
println(list1.zipWithNext()) // [(1, 2), (2, 3), ..., (4, 5)]
```

### 컬렉션 그룹화

* groupBy 를 통한 그룹핑
* `Map<Key, List<Value>>` 로 객체가 생성됨

  
