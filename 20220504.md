
# 7장 코틀린을 사용한 비동기 프로그래밍
### [코루틴](https://ko.wikipedia.org/wiki/%EC%BD%94%EB%A3%A8%ED%8B%B4)
* 책에서는 경량 스레드로 정의하고 있으나 틀린 말
* 코루틴(coroutine)은 루틴의 일종으로서, 협동 루틴이라 할 수 있다(코루틴의 "Co"는 with 또는 togather를 뜻한다). 상호 연계 프로그램을 일컫는다고도 표현가능하다. 루틴과 서브 루틴은 서로 비대칭적인 관계이지만, 코루틴들은 완전히 대칭적인, 즉 서로가 서로를 호출하는 관계이다. 코루틴들에서는 무엇이 무엇의 서브루틴인지를 구분하는 것이 불가능하다. 코루틴 A와 B가 있다고 할 때, A를 프로그래밍 할 때는 B를 A의 서브루틴으로 생각한다. 그러나 B를 프로그래밍할 때는 A가 B의 서브루틴이라고 생각한다. 어떠한 코루틴이 발동될 때마다 해당 코루틴은 이전에 자신의 실행이 마지막으로 중단되었던 지점 다음의 장소에서 실행을 재개한다.[1]

### JVM 스레드
JVM 에서 비동기 동시 어플리케이션의 빌딩 블록을 의미하며 OS 의 네이티브 스레드를 생성하게 된다 - project loom 에서 코루틴과 비슷한 가상 스레드가 생길 예정

#### JVM 스레드 단점
비용이 크고 생성/제거(가비지컬렉션)/컨텍스트 스위치에 CPU, 메모리 자원을 크게 소모한다

스레드를 많이 생성할 경우 OOM 이 발생할 가능성이 크다

### 동기/비동기 구현 비교

||코드복잡성|리소스 소비
|---|---|---
|동기|낮음|많고 느림
|콜백|매우 높은 어댑터 필요, 읽기 힘듦|자원 소비가 높음 Executor 를 사용하면 괜찮긴 하지만 복잡도가 올라감
|퓨처|중간, 그러나 여전히 어려움|리소스 소비가 높지만 Executor 로 조절 가능
|프로미스|프로미스 스타일(then, success)를 사용하면 중간, 퓨처 스타일(get)을 사용하면 코루틴과 비슷하게 사용 가능|소비는 매우 높고최고의퍼포먼스를갖지만코드변경 없이미세 조정 가능
|코루틴|복잡도 낮음|리소스 소비 낮고 최상의 성능

* 코버넌트를 사용하면 JS Promise 랑 비슷하게 사용 가능

### 채널
... TODO

# 8장 코틀린의 컬렉션과 데이터 작업

코틀린의 컬렉션 프레임워크는 자바보다 훨씬 기능적

### 컬렉션 소개
컬렉션 프레임워크는 다음과 같은 공통 데이터 관련 작업 그룹을 수행하기 위한 통합 아키텍쳐를 제공하는 클래스와 인터페이스 세트다
* 검색
* 정렬
* 삽입
* 삭제
* 조작

### 장점
가변/불변을 구분할 수 있는 인터페이스 구조
![image](https://user-images.githubusercontent.com/5905201/166584414-8474298b-5d9d-47cd-9ba5-2c8b7b1f4ea1.png)
* 지난번 스터디에서처럼 MustableXXX 로 필드를 객체 내부에 private 으로 생성하고 외부 오픈시 Immutable 형태로 노출 가능

### 특수한 컬렉션 동작들

* Map
  * to
  * mapOf( 123 to 456 )
  * map["key"]
    * operator 를 이용한 접근
* List
  * list[123]
    * operator 를 이용한 접근
* Set
  * set["key"]
    * operator 를 이용한 접근
* 데이터 조작 함수
  * map, filter, flatMap - 우리가 알고 있는 동작
  * drop - n 번째까지 데이터를 삭제한 새 컬렉션을 생성
  * take - n 번째 까지 데이터만 포함된 새 컬렉션을 생성
  * zip - 압축 한다는 의미이지만 와 닿지는 않고 실제로는 두 컬렉션을 하나로 합쳐서 컬렉션의 pair 컬렉션을 생성
    * 수행한 컬렉션 갯수 기준으로 새 컬렉션 생성

```kotlin
val list = listOf(1,2,3,4,5)
val list2 = listOf("item1", "item2", "item3", "item4", "item5", "item6")

println(list1.zip(list2)) // [(1, item1), (2, item3), ..., (5, item5)]
println(list1.zipWithNext()) // [(1, 2), (2, 3), ..., (4, 5)]
```

### 컬렉션 그룹화

* groupBy 를 통한 그룹핑
* `Map<Key, List<Value>>` 로 객체가 생성됨

  
