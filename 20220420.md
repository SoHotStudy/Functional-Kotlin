## 3장에서 못다한 얘기

### 불변 컬렉션으로 노출하기
MutableIterator는 Iterator를 상속함. 따라서 모든 MutableXXX는 안전한 업캐스팅으로 별도의 비용없이 이뮤터블컬렉션으로 변환할 수 있음.
따라서 코틀린에서는 외부 노출 속성을 이뮤터블로 바꿔주는 패턴이 흔하게 쓰임
```kotlin
class Some{
 private val _data = hashMapOf("a" to 3, "b" to 5)
 val data = _data as Map<String, Int>
}
```

## 4장

### 람다와 지역함수의 차이점
* return - 람다는 return@를 통해 람다레이블을 줘야만 return가능. fun은 return이 쉽게 가능
* 인라인 인자로 주어질 시 return - 람다는 return만 쓰면 감싼 함수의 return으로 처리되고, fun은 오히려 return@외부함수명 으로 반환해야 함
```kotlin
//일반상황
fun test1(block:()->Int):Int{
  return block()
}
fun action1(){
  val check = 3
  test1{
    if(check > 1) return@test1 5
    6
  }
  test1(fun():Int{
    if(check > 1) return 5
    return 6
  })
}

//inline상황
inline fun test2(block:()->Int):Int{
  return block()
}

fun action2(){
 test2{
   return
 }
 test2(fun():Int{
   return@action2
 })
}
```

### 자바와 코틀린 람다의 근본적인 차이점
- 자바 : 람다는 비록 런타임에 람다팩토리를 이용해 효과적인 인스턴스를 만들어낼 지언정 기본적으로 특정 인터페이스의 익명클래스인스턴스임. 즉 람다는 존재하지 않고 인터페이스의 익명인스턴스가 존재할 뿐임. 따라서 모든 람다는 태어날 때부터 인터페이스의 형으로 규정할 수 있음.
- 코틀린 : 람다는 언어차원의 특수 리플렉션 타입인 KFunction임. 이 타입은 우리가 런타임에 인식하는 타입이 아닌 언어가 컴파일차원에서 정의에 활용되는 리플렉션 타입임. 따라서 모든 람다는 런타임 타입이 없는 상태임. 언어차원의 진정한 람다가 별도로 존재함. 따라서 람다 문법은 함부러 다른 인터페이스의 타입으로 치환되지 않음.
- SAM선언 : 그러므로 코틀린에서는 이 람다가 특정 인터페이스형을 구현한 것이라는 힌트를 줘야하고 그게 SAM선언 및 사용임
```kotlin
//SAM선언
fun interface Test{
  opertator fun invoke()
}
//SAM사용
val fn = Test{...}
//JAVA인터페이스 구상
val runnable = Runnable{...}
```
### Unit, Nothing
Unit에 대해
* 고대언어에는 반환값이 있는 함수와 반환값이 없는 프로시저를 아예 언어차원에서 다른 키워드로 생성하게 하는 경우도 있음(베이직)
* 절차지향 프로그래밍은 번역이 잘못된 것으로 엄밀하게는 프로시저(이걸 절차로 번역한..미친) 지향 프로그래밍임
* 자바에서는 void라는 언어특수 타입을 통해 프로시저를 정의함. 이 결과 void는 형이지만 형이 아닌 특수한 예외가 됨(제네릭에 쓸 수 없다던가..)
* 코틀린은 아예 프로시저의 개념을 제거하고 무조건 함수만 쓰도록 하되 Unit이라는 싱글톤 객체를 반환하는 경우 암묵적으로 Unit을 생략할 수 있게만 지원함
* js에서도 비슷한 컨셉으로 undefined라는 값을 사용함

Nothing에 대해
* 객체 지향 언어의 궁극적인 목표는 언어를 사용할 때 문(statement-if,for,...)을 식(객체나 함수나 값)으로 대체하는 것임
* 문의 경우 컴파일이 아니면 내용을 바꿀 수 없고
* 한 번 실행되면 재실행할 수 없으며
* 원하는 시점에 실행할 수도 없음
따라서
* 적어도 문을 함수에 가두는 것으로 여러번 실행하거나 원하는 시점에 실행할 수 있게 하는 것을 기본으로
* 객체를 비롯한 다양한 구조물을 이용해 문의 상황을 식의 형태로 바꿔서 통제하려고 함
* 모든 문을 전부 식으로 대체하여 통제하는 패턴을 커맨드패턴이라함. 코드에서 사용할 모든 문을 하나하나 객체로 바꿔서 원하는 조합과 시점과 방식으로 실행할 수 있게 함.

여기까지를 고려하면 문을 식으로 바꾸려는 행위는 설계의 유연성에서 당연한 선택지임.
(if문은 케이스를 늘릴려면 컴파일해야하지만 전략패턴을 쓰면 전략객체를 사용하는 함수측은 컴파일 하지 않아도 되므로 OCP가 달성되는 식)

즉 문이 식(객체)로 대체된다는 의미는 문이 어떤 객체의 형으로 치환된다는 뜻임. 전형적인 커맨드 패턴의 예제인 SQL래퍼를 생각해보면
From, Where, Select 등의 객체가 나와서 거기에 적당히 값을 넣으면 이들 객체의 조합으로 실제로는 조합기가 sql을 실행하는 문을 만들어내게 됨.
즉 각각 실행해야 하는 문을 From, Where 등의 객체로 대체했고 더 나아가 From Where형으로 대체했다고 볼 수 있음.

문--->식--->형  즉 문을 형으로 바꿈

이를 컴파일 수준에서 반영하는 개념이 Nothing임. 원래 문인 throw를 코틀린에서는 식으로 바꿨는데 throw가 식이 되려면 반드시 throw라는 행위가 객체화되고 나아가 형이 되어야함.

```kotlin
val a:Int = throw Throwable("aa")
```

위 문장이 성립하는 이유는 throw가 식(객체)이기 때문이고 문으로 하던 일을 처리하는 일종의 커맨드 객체라고 보면 됨. 따라서 예외행위에 대한 커맨드객체의 타입이 필요했고..
이가 바로 Nothing으로 그 특성상 null처럼 모든 타입에 매칭되어야했기 때문에 Nothing은 어떤 타입과도 호환되는 최종 구상객체형임. 
Any?가 모든 형의 부모라면 Nothing은 모든 형의 자식임

그러므로 우리는 Nothing을 반환하는 어떤 식이라도 아무 타입에 적용할 수 있으며 이를 통해 throw문을 식으로 손쉽게 대체할 수 있음.
```kotlin
//기존 예외가 문일때의 발상
if(check){
  //예외
  throw...
}else{
  return 3  
}
//예외도 식이라는 발상
return if(check) Nothing else 3
//Nothing 그 자체 혹은 그에 준하는 Nothing반환하는 식을 값으로 씀
```


## 05

### 인자의 기본값 vs 오버로딩
* 함수의 인자에 차이가 있는 경우 인자를 다르게 한 같은 이름의 함수를 만드는 오버로딩을 하던가 기본값을 넣어서 확장할 수 있음
* 만약 인자의 형이 바뀐다면 오버로딩밖에 안됨
* 선택적 인자라면 기본값이 바람직함
```kotlin
//오버로딩 외엔 방법이 없음(형이 달라짐)
fun op(a:Int, b:Int):Int
fun op(a:Long, b:Int):Long
fun op(a:Int, b:Long):Long
fun op(a:Long, b:Long):Long

//인자 갯수에 대한 오버로딩은 
fun op2(a:Int):Int
fun op2(a:Int, b:Int):Int
//기본값으로 대체
fun op2(a:Int, b:Int = 0):Int
```
* 코틀린의 인자 기본값은 함수 본문내의 제어문으로 구현되므로 좌측 인자를 우측인자를 인식할 수 있고 인자순서로 순차처리됨.
```kotlin
//인자 기본값으로 조지기
fun op(a:Int, b:Int = a, c:Int = f1(a, b), d:Int = if(c>5) 6 else throw Throwable("aa")):Int
```
~~~
