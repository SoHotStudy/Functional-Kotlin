## 3장에서 못다한 얘기

### 불변 컬렉션으로 노출하기
MutableIterator는 Iterator를 상속함. 따라서 모든 MutableXXX는 안전한 업캐스팅으로 별도의 비용없이 이뮤터블컬렉션으로 변환할 수 있음.
따라서 코틀린에서는 외부 노출 속성을 이뮤터블로 바꿔주는 패턴이 흔하게 쓰임
```kotlin
class Some{
 private val _data = hashMapOf("a" to 3, "b" to 5)
 val data = _data as Map<String, Int>
}
```

## 4장

### 람다와 지역함수의 차이점
* return - 람다는 return@를 통해 람다레이블을 줘야만 return가능. fun은 return이 쉽게 가능
* 인라인 인자로 주어질 시 return - 람다는 return만 쓰면 감싼 함수의 return으로 처리되고, fun은 오히려 return@외부함수명 으로 반환해야 함
```kotlin
//일반상황
fun test1(block:()->Int):Int{
  return block()
}
fun action1(){
  val check = 3
  test1{
    if(check > 1) return@test1 5
    6
  }
  test1(fun():Int{
    if(check > 1) return 5
    return 6
  })
}

//inline상황
inline fun test2(block:()->Int):Int{
  return block()
}

fun action2(){
 test2{
   return
 }
 test2(fun():Int{
   return@action2
 })
}
```

### 자바와 코틀린 람다의 근본적인 차이점
- 자바 : 람다는 비록 런타임에 람다팩토리를 이용해 효과적인 인스턴스를 만들어낼 지언정 기본적으로 특정 인터페이스의 익명클래스인스턴스임. 즉 람다는 존재하지 않고 인터페이스의 익명인스턴스가 존재할 뿐임. 따라서 모든 람다는 태어날 때부터 인터페이스의 형으로 규정할 수 있음.
- 코틀린 : 람다는 언어차원의 특수 리플렉션 타입인 KFunction임. 이 타입은 우리가 런타임에 인식하는 타입이 아닌 언어가 컴파일차원에서 정의에 활용되는 리플렉션 타입임. 따라서 모든 람다는 런타임 타입이 없는 상태임. 언어차원의 진정한 람다가 별도로 존재함. 따라서 람다 문법은 함부러 다른 인터페이스의 타입으로 치환되지 않음.
- SAM선언 : 그러므로 코틀린에서는 이 람다가 특정 인터페이스형을 구현한 것이라는 힌트를 줘야하고 그게 SAM선언 및 사용임
```kotlin
//SAM선언
fun interface Test{
  opertator fun invoke()
}
//SAM사용
val fn = Test{...}
//JAVA인터페이스 구상
val runnable = Runnable{...}
```
### Unit, Nothing
Unit에 대해
* 고대언어에는 반환값이 있는 함수와 반환값이 없는 프로시저를 아예 언어차원에서 다른 키워드로 생성하게 하는 경우도 있음(베이직)
* 절차지향 프로그래밍은 번역이 잘못된 것으로 엄밀하게는 프로시저(이걸 절차로 번역한..미친) 지향 프로그래밍임
* 자바에서는 void라는 언어특수 타입을 통해 프로시저를 정의함. 이 결과 void는 형이지만 형이 아닌 특수한 예외가 됨(제네릭에 쓸 수 없다던가..)
* 코틀린은 아예 프로시저의 개념을 제거하고 무조건 함수만 쓰도록 하되 Unit이라는 싱글톤 객체를 반환하는 경우 암묵적으로 Unit을 생략할 수 있게만 지원함
* js에서도 비슷한 컨셉으로 undefined라는 값을 사용함

Nothing에 대해
* 객체 지향 언어의 궁극적인 목표는 언어를 사용할 때 문(statement-if,for,...)을 식(객체나 함수나 값)으로 대체하는 것임
* 문의 경우 컴파일이 아니면 내용을 바꿀 수 없고
* 한 번 실행되면 재실행할 수 없으며
* 원하는 시점에 실행할 수도 없음
따라서
* 적어도 문을 함수에 가두는 것으로 여러번 실행하거나 원하는 시점에 실행할 수 있게 하는 것을 기본으로
* 객체를 비롯한 다양한 구조물을 이용해 문의 상황을 식의 형태로 바꿔서 통제하려고 함
* 모든 문을 전부 식으로 대체하여 통제하는 패턴을 커맨드패턴이라함. 코드에서 사용할 모든 문을 하나하나 객체로 바꿔서 원하는 조합과 시점과 방식으로 실행할 수 있게 함.

여기까지를 고려하면 문을 식으로 바꾸려는 행위는 설계의 유연성에서 당연한 선택지임.
(if문은 케이스를 늘릴려면 컴파일해야하지만 전략패턴을 쓰면 전략객체를 사용하는 함수측은 컴파일 하지 않아도 되므로 OCP가 달성되는 식)

즉 문이 식(객체)로 대체된다는 의미는 문이 어떤 객체의 형으로 치환된다는 뜻임. 전형적인 커맨드 패턴의 예제인 SQL래퍼를 생각해보면
From, Where, Select 등의 객체가 나와서 거기에 적당히 값을 넣으면 이들 객체의 조합으로 실제로는 조합기가 sql을 실행하는 문을 만들어내게 됨.
즉 각각 실행해야 하는 문을 From, Where 등의 객체로 대체했고 더 나아가 From Where형으로 대체했다고 볼 수 있음.

문--->식--->형  즉 문을 형으로 바꿈

이를 컴파일 수준에서 반영하는 개념이 Nothing임. 원래 문인 throw를 코틀린에서는 식으로 바꿨는데 throw가 식이 되려면 반드시 throw라는 행위가 객체화되고 나아가 형이 되어야함.

```kotlin
val a:Int = throw Throwable("aa")
```

위 문장이 성립하는 이유는 throw가 식(객체)이기 때문이고 문으로 하던 일을 처리하는 일종의 커맨드 객체라고 보면 됨. 따라서 예외행위에 대한 커맨드객체의 타입이 필요했고..
이가 바로 Nothing으로 그 특성상 null처럼 모든 타입에 매칭되어야했기 때문에 Nothing은 어떤 타입과도 호환되는 최종 구상객체형임. 
Any?가 모든 형의 부모라면 Nothing은 모든 형의 자식임

그러므로 우리는 Nothing을 반환하는 어떤 식이라도 아무 타입에 적용할 수 있으며 이를 통해 throw문을 식으로 손쉽게 대체할 수 있음.
```kotlin
//기존 예외가 문일때의 발상
if(check){
  //예외
  throw...
}else{
  return 3  
}
//예외도 식이라는 발상
return if(check) Nothing else 3
//Nothing 그 자체 혹은 그에 준하는 Nothing반환하는 식을 값으로 씀
```

### 순수함수와 부수효과
함수는 순수하게 짜는 편이 생각하기 편함.
- 전역 상태에 의존하는 부수효과를 가진 함수는 싱글톤 객체의 메소드로 구성하는 게 나음.
부수효과는 클래스의 메소드로 만드는 편이 생각하기 편함.
- 클래스의 메소드가 this컨텍스트를 사용하지 않는다면 순수함수인 것을 의심해야하고 메소드에서 제외시켜야 함.

* 공개속성을 이용하는 함수는 어떻게 바라볼 것인가?


## 5장

### vararg의 특수한 경우
```kotlin
fun action(a:Int, vararg b:String, block:()->Unit){..}

action(3, "a", "b", "c"){
  ...
}
```

### 인자의 기본값 vs 오버로딩
* 함수의 인자에 차이가 있는 경우 인자를 다르게 한 같은 이름의 함수를 만드는 오버로딩을 하던가 기본값을 넣어서 확장할 수 있음
* 만약 인자의 형이 바뀐다면 오버로딩밖에 안됨
* 선택적 인자라면 기본값이 바람직함
```kotlin
//오버로딩 외엔 방법이 없음(형이 달라짐)
fun op(a:Int, b:Int):Int
fun op(a:Long, b:Int):Long
fun op(a:Int, b:Long):Long
fun op(a:Long, b:Long):Long

//인자 갯수에 대한 오버로딩은 
fun op2(a:Int):Int
fun op2(a:Int, b:Int):Int
//기본값으로 대체
fun op2(a:Int, b:Int = 0):Int
```
* 코틀린의 인자 기본값은 함수 본문내의 제어문으로 구현되므로 좌측 인자를 우측인자를 인식할 수 있고 인자순서로 순차처리됨.
```kotlin
//인자 기본값으로 조지기
fun op(a:Int, b:Int = a, c:Int = f1(a, b), d:Int = if(c>5) 6 else throw Throwable("aa")):Int
```

### 확장함수와 대체가능성
* 언제 확장함수를 써야하는가?

**문제점**
근본적으로 확장함수는 첫번째 인자가 리시버인 함수의 편의 표현일 뿐이고 실제 시그니쳐도 완전히 동일함.
```kotlin
fun Some.action(a:Int, b:Int){
  ...
}
Some().action(1, 2)
     or
action(Some(), 1, 2)
```
단 처음부터 확장함수 형식으로 작성하지 않은 경우 점을 통한 연결문법을 지원하지 않을 뿐임
```kotlin
fun action(some:Some, a:Int, b:Int){
  ...
}
// Some().action(1, 2) 불가
action(Some(), 1, 2)
```
하지만 확장함수는 대체가능성과 내적동질성을 지원하지 않기 때문에 문법 자체가 오류를 일으킴. 
확장함수는 그 원리상 대체가능성을 제공하지 않음. 따라서 근본적으로 객체지향 원리를 위반함(책의 코드는 다운캐스팅을 시도)

원천적으로는 사용하면 안되지만 확장함수로 작성하면 코드힌트를 쉽게 받을 수 있음. 만약 확장함수 형식이 아니라면 함수 이름을 어느 정도는 알아야 코드힌트를 받을 수 있음.
this.을 생략함으로서 얻을 수 있는 장점이 있지만 DSL을 다중 스코프로 사용하는 경우 일종의 this 쉐도우가 발생하여 꼭 바람직하다고 볼 수 없음.

### 메소드에 확장함수를 쓰는 경우에 대한 고찰
```kotlin
class Dispatcher{
  fun Cat.react() = "cat"
  fun Animal.react() = "animal"
  fun react(cat:Cat){
    println(cat.react())
  }
  fun react(animal:Animal){
    println(animal.react())
  }
}
Dispatcher().react(Animal())
Dispatcher().react(Cat())
Dispatcher().Inner().react(Animal())
Dispatcher().Inner().react(Cat())
with(Dispatcher()){
  println(Animal().react())
  println(Cat().react())
}
```

중첩된 this컨텍스트 하에서 발휘됨. 따라서 외부에 노출하는 경우는 with등의 사용을 염두할 때 밖에 없으므로 억지스러움. 보통 private가 정상.

### Companion의 확장함수
확장함수로 구현하는 방법과 인터페이스 기본구현으로 처리하는 방법이 있음
```kotlin
class Test1{
  compaion object
}
fun Test1.Companion.action(){..}
Test1.action()

class Test2{
  compaion object:Action
}
interface Action{
  fun action(){..}
}
Test2.action()
```

### inline 체이닝
인라인 함수는 넘겨진 블록을 인라인화하지만 인라인을 끝까지 체이닝하지 않으면 람다객체의 생성을 막을 수는 없음
```kotlin
fun test203(block:()->Unit){ //인라인 함수가 아님
    listOf(1,2,3).forEach { block() } //인라인 함수
}
fun main(vararg arg:String) {
    test203{
        println("a")
    }
}
```
forEach는 인라인이지만 test203은 인라인이 아님. 이 경우 컴파일러는 최대한 인라인 컨텍스트가 유지되는 곳까지 인라인화하는 전략을 택함.
js로 컴파일 결과를 보면 다음과 같음
```js
  function test203(block) {
    {
      var tmp0_forEach_0 = listOf([1, 2, 3]);
      var tmp0_iterator_1 = tmp0_forEach_0.iterator_jk1svi_k$();
      while (tmp0_iterator_1.hasNext_bitz1p_k$()) {
        var element_2 = tmp0_iterator_1.next_20eer_k$();
        {
          block();
        }
      }
    }
  }
  function main(arg) {
    test203(main$lambda());
  }
  function main$lambda() {
    return function () {
      console.log("a")
    };
  }
```
test203은 인라인화되지만 main$lambda람다객체의 생성은 막을 수 없음.
따라서 되도록 호출의 터미널까지 인라인 체인을 할 수록 효율적임.
단점 - 메소드를 인라인화하면 관련된 속성이 전부 공개속성이어야해서 은닉이나 캡슐화가 풀림.
```kotlin
inline fun test203(block:()->Unit){
    listOf(1,2,3).forEach { block() }
}
fun main(vararg arg:String) {
    test203{
        println("a")
    }
}

```
마지막까지 인라인화를 하면 다음과 같이 컴파일됨.
```js
  function test203(block) {
    {
      var tmp0_forEach_0 = listOf([1, 2, 3]);
      var tmp0_iterator_1 = tmp0_forEach_0.iterator_jk1svi_k$();
      while (tmp0_iterator_1.hasNext_bitz1p_k$()) {
        var element_2 = tmp0_iterator_1.next_20eer_k$();
        {
          block();
        }
      }
    }
  }
  function main(arg) {
    {
      {
        var tmp0_forEach_0_1 = listOf([1, 2, 3]);
        var tmp0_iterator_1_2 = tmp0_forEach_0_1.iterator_jk1svi_k$();
        while (tmp0_iterator_1_2.hasNext_bitz1p_k$()) {
          var element_2_3 = tmp0_iterator_1_2.next_20eer_k$();
          {
            {
              console.log("a")
            }
          }
        }
      }
    }
  }
```
람다객체의 생성이 아예 제거되고 인라인화가 main내부에서 일어남. 하지만 그렇다고 test203이 제거되는 것은 아니고 생성되긴 함(jvm동일)

## 6장

### 속성델리게이트의 정체

속성에 필드객체를 직접 넣는 경우
```kotlin
class Field<T>(var value:T){
  fun get() = value
  fun set(v:T){
    value = v
  }
}

class Record(n:String, a:Int{
  val name = Field(n)
  val age = Field(a)
}

val record = Record("hika", 20);
record.name.get()
record.name.set("tester")
record.age.get()
record.age.set(25)
```
여기에 get, set을 제거하고 일반적인 변수처럼 보이게 해주는 편의문법으로 다음의 조건을 준수한다.
1. Field객체가 operator getValue, setValue를 구상할 것
2. 속성을 =로 할당하지 말고 by로 할당할 것

```kotlin
class Field<T>(var value:T){
  operator fun getValue(ref:Any?, prop: KProperty<*>) = value
  operator fun setValue(ref:Any?, prop: KProperty<*>, v:T){
    value = v
  }
}

class Record(n:String, a:Int{
  val name by Field(n)
  val age by Field(a)
}

val record = Record("hika", 20);
record.name
record.name = "tester"
record.age
record.age = 25
```

### map을 이용한 속성 델리게이터 만들어보기

```kotlin
class MapField(val map:MutableMap<String, Any>){
  operator fun <T:Any>getValue(ref:Any?, prop: KProperty<*>) = (map[prop.name] as? T) ?: throw Throwable("no data")
  operator fun <T:Any>setValue(ref:Any?, prop: KProperty<*>, v:T){
    map[prop.name] = v
  }
}

class Record(map:MutableMap<String, Any>){
  var name by MapField(map)
  var age by MapField(map)
}

val record = Record(hashMapOf(
  "name" to "hika", 
  "age" to 20
);
record.name
record.name = "tester"
record.age
record.age = 25
```
코틀린 내장 map은 map객체 자체에 getValue, setValue가 설정되어 있음. 이를 흉내내 구현하기

```kotlin
class FieldMap:MutableMap<String, Any> by hashMapOf(){
  operator fun <T:Any>getValue(ref:Any?, prop: KProperty<*>) = (this[prop.name] as? T) ?: throw Throwable("no data")
  operator fun <T:Any>setValue(ref:Any?, prop: KProperty<*>, v:T){
    this[prop.name] = v
  }
}

class Record(map:FieldMap){
  var name:String by map
  var age:Int by map
}

val record = Record(FieldMap().also{
  it["name"] = "hika"
  it["age"] = 20
});

record.name
record.name = "tester"
record.age
record.age = 25
```

