## Arrow-kt DataStructure

`Arrow-kt` 에서 사용되는 데이터 자료 구조들을 배워보자 🧃  

## 목차
- [Arrow-kt DataStructure](#arrow-kt-datastructure)
- [목차](#목차)
- [Core](#core)
  - [Option](#option)
  - [Either](#either)
  - [Monad Comprehensions](#monad-comprehensions)
- [Optics](#optics)
- [그 외 나머지](#그-외-나머지)
  - [Fx](#fx)
  - [Analysis and Meta](#analysis-and-meta)
- [참고 링크](#참고-링크)


## Core

Arrow Kt 에서 제공해주는 메인 Data Type 추상화된 클래스들을 제공하는 역할  


### Option

쉽게 설명하자면, Kotlin 에서 제공해주는 `?` 와 비슷한 역할을 하나, 훨씬 더 많은 추상화 인터페이스들을 제공한다  
`Option` 이라는 `sealed class` 와 구현체로는 값이 존재하지 않는 `None` 과 존재하는 `Some` 으로 존재한다  


```kotlin
sealed class Option<out A>

object None : Option<Nothing>()

data class Some<out T>(val value: T) : Option<T>()

```

`None` 이라는 것은 단순하게 아래 예시 처럼 사용이 가능하다 

```kotlin

private fun maybeItWillReturnSomething(flag: Boolean): Option<String> {
    return if (flag) Some("Found Value") else None
}

fun main() {
    val value1 = maybeItWillReturnSomething(false).getOrElse { "No Value" }
    println("No Value" == value1)
}
```


명시적인 값에 대한 흐름과 `None` 과 `Some` 을 공통으로 묶을 수 있는 편리한 인터페이스를 제공한 Wrapper Class  

```kotlin
fun main() {
    val some = 1.some()
    val none = none<Int>()

    println(some.map { it * 3 } == 3.some())
    println(none.map { it * 3 } == none<Int>())
}
```

Arrow kt 에서는 `continuations` 패키지에 코루틴을 위한 비동기 기능도 제공한다  

```kotlin
suspend fun value(): Option<Int> = option {
    val a = Some(1).bind() // 1 중단 지점 
    val b = Some(1 + a).bind() // 2 중단 지점
    val c = Some(1 + b).bind() // 3 중단 지점
    a + b +c
}

suspend fun main() {
    println(value())
}
```


### Either

`kotlin` 진영에서의 예외처리는 함수의 호출자에서 내부 깊숙히 코드를 파헤쳐야 어떤 에러가 발생하는지 알게 됨  
이는 매우 개발 생산성을 떨어뜨리며, 내부 구현체까지 모두 알아야 한다는 제약사항이 많은 개발 방식  

따라서, `Either` 라는 인터페이스를 통해 반환하는 **데이터 유형에서 명시적** 으로 만드는 개발 철학  

```kotlin
public sealed class Either<out A, out B>

public data class Left<out A> constructor(val value: A) : Either<A, Nothing>()

public data class Right<out B> constructor(val value: B) : Either<Nothing, B>()

public sealed class Validated<out E, out A>

public data class Invalid<out E>(val value: E) : Validated<E, Nothing>()

public data class Valid<out A>(val value: A) : Validated<Nothing, A>()
```

`Validated` 는 에러를 축적하는데 사용되지만, `Either` 는 단순하게 첫번째 에러만 계산하는 것이 Convention  

또한, Left Value 는 에러 Value 를, Right Value 는 성공 Value 를 담는 것이 Convention

*개인적으로 생각하기에 Either 는 Go 언어에서 함수 호출시 Result와 Nil 을 리턴하는 방식과 비슷하다고 생각*

```kotlin
import arrow.core.Either

fun parse(s: String): Either<NumberFormatException, Int> =
    if (s.matches(Regex("-?\\d+"))) Either.Right(s.toInt())
    else Either.Left(NumberFormatException("$s is not a valid integer."))

fun main() {
    val notNumber = parse("Not a number")
    val number = parse("2")

    println(notNumber) // Either.Left(java.lang.NumberFormatException: Not a number is not a valid integer.)
    println(number) // Either.Right(2)
}
```

### Monad Comprehensions

`Monad Comprehensions` 은 프로그래머의 코드 스타일을 자연스러운 흐름의 체이닝 스타일을 유지할 수 있게 제공하는 방식 


```kotlin
import arrow.core.Either
import arrow.core.continuations.either
import arrow.core.left
import arrow.core.right

object NotFound
data class Name(val value: String)
data class UniversityId(val value: String)
data class University(val name: Name, val deanName: Name)
data class Student(val name: Name, val universityId: UniversityId)
data class Dean(val name: Name)

private val students = mapOf(
    Name("Alice") to Student(Name("Alice"), UniversityId("UCA"))
)

private val universities = mapOf(
    UniversityId("UCA") to University(Name("UCA"), Name("James"))
)

private val deans = mapOf(
    Name("James") to Dean(Name("James"))
)

fun student(name: Name): Either<NotFound, Student> {
    println("called student, $name")
    return students[name]?.right() ?: NotFound.left()
}

fun university(id: UniversityId): Either<NotFound, University> {
    println("called university, $id")
    return universities[id]?.right() ?: NotFound.left()
}

fun dean(name: Name): Either<NotFound, Dean> {
    println("called dean, $name")
    return deans[name]?.right() ?: NotFound.left()
}

suspend fun main() {
    val dean = either<NotFound, Dean> {
        val alice = student(Name("Alice")).bind() // 1번 중단
        val uca = university(alice.universityId).bind() // 2번 중단
        val james = dean(uca.deanName).bind() // 3번 중단
        james
    }

    val notFound = either<NotFound, Dean> {
        val paul = student(Name("Paul")).bind()
        val uca = university(paul.universityId).bind()
        val james = dean(uca.deanName).bind()
        james
    }

    println(dean) // 모든 함수를 타게됨
    println(notFound) // student 함수만 호출하게 됨
}
```

student 이라는 함수에 `Alice` 를 파라미터로 넘기면, 자연스럽게 다음 함수인 `university` 함수를 호출해서 `University` 객체를 가져오고, 가져왔으면 마찬가지로 자연스럽게 다음 함수인 `dean` 함수를 호출해서 `Dean` 객체를 가져오게 됩니다.  

만일 알 수 없는 이름을 던진다면, `Student` 객체를 찾을 수 없으므로, 호출되지 않게 됩니다.

참고나마 `either` 라는 `scope` 는 코루틴 scope 이며 arrow 에서 지원해주는 인터페이스 입니다.  

```kotlin
@Suppress("ClassName")
public object either {
  public inline fun <E, A> eager(crossinline f: suspend EagerEffectScope<E>.() -> A): Either<E, A> =
    eagerEffect(f).toEither()

  public suspend inline operator fun <E, A> invoke(crossinline f: suspend EffectScope<E>.() -> A): Either<E, A> =
    effect(f).toEither()
}
```


## Optics

불변 데이터를 변환하거나 연산하는데에 있어서 추상화된 레벨  

Optics 의 종류중의 하나인 `Lens` 를 예시로 설명해보겠습니다.  

```kotlin
import arrow.optics.Lens

data class Product(val name: String)
data class OrderItem(val quantity: Long, val product: Product)
data class Order(val purchaserName: String, val orderItem: OrderItem)

// 이러한 것은 arrow kt 에서 지원해주는 kapt 기능을 통하여 자동생성이 가능하다. @optics 어노테이션 기반
private val orderOrderItem: Lens<Order, OrderItem> = Lens(
    get = { it.orderItem },
    set = { order, orderItem -> order.copy(orderItem = orderItem) }
)

private val orderItemProduct: Lens<OrderItem, Product> = Lens(
    get = { it.product },
    set = { orderItem, product -> orderItem.copy(product = product) }
)

private val productName: Lens<Product, String> = Lens(
    get = { it.name },
    set = { product, name -> product.copy(name = name) }
)


fun main() {
    val order = Order(
        purchaserName = "customer",
        orderItem = OrderItem(
            quantity = 1L,
            product = Product(name = "productA")
        )
    )

    val order2 = order.copy(
        orderItem = order.orderItem.copy(
            product = order.orderItem.product.copy(
                name = "productB"
            )
        )
    )

    val orderCopyOnlyProductName: Lens<Order, String> = orderOrderItem compose orderItemProduct compose productName
    val order3 = orderCopyOnlyProductName.modify(order) { "productB" }

    println(order2.orderItem.product.name == order3.orderItem.product.name)
}
```


## 그 외 나머지

아무래도 제가 다 정리하기에는 벅차서, 나머지 모듈들에 대해서는 간단하게 소개만 할까 합니다.

### Fx

코틀린의 `Coroutine` 과 조합하여, 함수형 프로그래밍을 비동기로 처리할 수 있는 인터페이스를 제공

### Analysis and Meta

코틀린 `compile` 시간에 Arrow 에서 제공하는 데이터 유형에 대한 컴파일 에러를 탐지하도록 추가하는 기능을 제공  

```kotlin

import arrow.analysis.pre

fun increment(x: Int): Int {
  pre(x > 0) { "value must be positive" }
  return x + 1
}
```

를 정의하고, `increment` 함수에 -1 을 파라미터로 하는 코드를 작성하고, compile 을 하면 에러 발생 

```kotlin
val example = increment(-1)
```

```text
e: pre-condition `value must be positive` is not satisfied in `increment(-1)`
  -> unsatisfiable constraint: `(-1 > 0)`
```

## 참고 링크

- [Arrow-kt-Core](https://arrow-kt.io/docs/core/)
- [Arrow-kt-Fx](https://arrow-kt.io/docs/fx/)
- [Arrow-kt-Optics](https://arrow-kt.io/docs/optics/traversal/)
- [Arrow-kt-Analysis](https://arrow-kt.io/docs/analysis/)
- [Arrow-kt-Meta](https://arrow-kt.io/docs/meta/)