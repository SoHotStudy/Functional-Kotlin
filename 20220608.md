## Arrow-kt DataStructure

`Arrow-kt` ì—ì„œ ì‚¬ìš©ë˜ëŠ” ë°ì´í„° ìë£Œ êµ¬ì¡°ë“¤ì„ ë°°ì›Œë³´ì ğŸ§ƒ  

## ëª©ì°¨
- [Arrow-kt DataStructure](#arrow-kt-datastructure)
- [ëª©ì°¨](#ëª©ì°¨)
- [Core](#core)
  - [Option](#option)
  - [Either](#either)
  - [Monad Comprehensions](#monad-comprehensions)
- [Optics](#optics)
- [ê·¸ ì™¸ ë‚˜ë¨¸ì§€](#ê·¸-ì™¸-ë‚˜ë¨¸ì§€)
  - [Fx](#fx)
  - [Analysis and Meta](#analysis-and-meta)
- [ì°¸ê³  ë§í¬](#ì°¸ê³ -ë§í¬)


## Core

Arrow Kt ì—ì„œ ì œê³µí•´ì£¼ëŠ” ë©”ì¸ Data Type ì¶”ìƒí™”ëœ í´ë˜ìŠ¤ë“¤ì„ ì œê³µí•˜ëŠ” ì—­í•   


### Option

ì‰½ê²Œ ì„¤ëª…í•˜ìë©´, Kotlin ì—ì„œ ì œê³µí•´ì£¼ëŠ” `?` ì™€ ë¹„ìŠ·í•œ ì—­í• ì„ í•˜ë‚˜, í›¨ì”¬ ë” ë§ì€ ì¶”ìƒí™” ì¸í„°í˜ì´ìŠ¤ë“¤ì„ ì œê³µí•œë‹¤  
`Option` ì´ë¼ëŠ” `sealed class` ì™€ êµ¬í˜„ì²´ë¡œëŠ” ê°’ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” `None` ê³¼ ì¡´ì¬í•˜ëŠ” `Some` ìœ¼ë¡œ ì¡´ì¬í•œë‹¤  


```kotlin
sealed class Option<out A>

object None : Option<Nothing>()

data class Some<out T>(val value: T) : Option<T>()

```

`None` ì´ë¼ëŠ” ê²ƒì€ ë‹¨ìˆœí•˜ê²Œ ì•„ë˜ ì˜ˆì‹œ ì²˜ëŸ¼ ì‚¬ìš©ì´ ê°€ëŠ¥í•˜ë‹¤ 

```kotlin

private fun maybeItWillReturnSomething(flag: Boolean): Option<String> {
    return if (flag) Some("Found Value") else None
}

fun main() {
    val value1 = maybeItWillReturnSomething(false).getOrElse { "No Value" }
    println("No Value" == value1)
}
```


ëª…ì‹œì ì¸ ê°’ì— ëŒ€í•œ íë¦„ê³¼ `None` ê³¼ `Some` ì„ ê³µí†µìœ¼ë¡œ ë¬¶ì„ ìˆ˜ ìˆëŠ” í¸ë¦¬í•œ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•œ Wrapper Class  

```kotlin
fun main() {
    val some = 1.some()
    val none = none<Int>()

    println(some.map { it * 3 } == 3.some())
    println(none.map { it * 3 } == none<Int>())
}
```

Arrow kt ì—ì„œëŠ” `continuations` íŒ¨í‚¤ì§€ì— ì½”ë£¨í‹´ì„ ìœ„í•œ ë¹„ë™ê¸° ê¸°ëŠ¥ë„ ì œê³µí•œë‹¤  

```kotlin
suspend fun value(): Option<Int> = option {
    val a = Some(1).bind() // 1 ì¤‘ë‹¨ ì§€ì  
    val b = Some(1 + a).bind() // 2 ì¤‘ë‹¨ ì§€ì 
    val c = Some(1 + b).bind() // 3 ì¤‘ë‹¨ ì§€ì 
    a + b +c
}

suspend fun main() {
    println(value())
}
```


### Either

`kotlin` ì§„ì˜ì—ì„œì˜ ì˜ˆì™¸ì²˜ë¦¬ëŠ” í•¨ìˆ˜ì˜ í˜¸ì¶œìì—ì„œ ë‚´ë¶€ ê¹Šìˆ™íˆ ì½”ë“œë¥¼ íŒŒí—¤ì³ì•¼ ì–´ë–¤ ì—ëŸ¬ê°€ ë°œìƒí•˜ëŠ”ì§€ ì•Œê²Œ ë¨  
ì´ëŠ” ë§¤ìš° ê°œë°œ ìƒì‚°ì„±ì„ ë–¨ì–´ëœ¨ë¦¬ë©°, ë‚´ë¶€ êµ¬í˜„ì²´ê¹Œì§€ ëª¨ë‘ ì•Œì•„ì•¼ í•œë‹¤ëŠ” ì œì•½ì‚¬í•­ì´ ë§ì€ ê°œë°œ ë°©ì‹  

ë”°ë¼ì„œ, `Either` ë¼ëŠ” ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ ë°˜í™˜í•˜ëŠ” **ë°ì´í„° ìœ í˜•ì—ì„œ ëª…ì‹œì ** ìœ¼ë¡œ ë§Œë“œëŠ” ê°œë°œ ì² í•™  

```kotlin
public sealed class Either<out A, out B>

public data class Left<out A> constructor(val value: A) : Either<A, Nothing>()

public data class Right<out B> constructor(val value: B) : Either<Nothing, B>()

public sealed class Validated<out E, out A>

public data class Invalid<out E>(val value: E) : Validated<E, Nothing>()

public data class Valid<out A>(val value: A) : Validated<Nothing, A>()
```

`Validated` ëŠ” ì—ëŸ¬ë¥¼ ì¶•ì í•˜ëŠ”ë° ì‚¬ìš©ë˜ì§€ë§Œ, `Either` ëŠ” ë‹¨ìˆœí•˜ê²Œ ì²«ë²ˆì§¸ ì—ëŸ¬ë§Œ ê³„ì‚°í•˜ëŠ” ê²ƒì´ Convention  

ë˜í•œ, Left Value ëŠ” ì—ëŸ¬ Value ë¥¼, Right Value ëŠ” ì„±ê³µ Value ë¥¼ ë‹´ëŠ” ê²ƒì´ Convention

*ê°œì¸ì ìœ¼ë¡œ ìƒê°í•˜ê¸°ì— Either ëŠ” Go ì–¸ì–´ì—ì„œ í•¨ìˆ˜ í˜¸ì¶œì‹œ Resultì™€ Nil ì„ ë¦¬í„´í•˜ëŠ” ë°©ì‹ê³¼ ë¹„ìŠ·í•˜ë‹¤ê³  ìƒê°*

```kotlin
import arrow.core.Either

fun parse(s: String): Either<NumberFormatException, Int> =
    if (s.matches(Regex("-?\\d+"))) Either.Right(s.toInt())
    else Either.Left(NumberFormatException("$s is not a valid integer."))

fun main() {
    val notNumber = parse("Not a number")
    val number = parse("2")

    println(notNumber) // Either.Left(java.lang.NumberFormatException: Not a number is not a valid integer.)
    println(number) // Either.Right(2)
}
```

### Monad Comprehensions

`Monad Comprehensions` ì€ í”„ë¡œê·¸ë˜ë¨¸ì˜ ì½”ë“œ ìŠ¤íƒ€ì¼ì„ ìì—°ìŠ¤ëŸ¬ìš´ íë¦„ì˜ ì²´ì´ë‹ ìŠ¤íƒ€ì¼ì„ ìœ ì§€í•  ìˆ˜ ìˆê²Œ ì œê³µí•˜ëŠ” ë°©ì‹ 


```kotlin
import arrow.core.Either
import arrow.core.continuations.either
import arrow.core.left
import arrow.core.right

object NotFound
data class Name(val value: String)
data class UniversityId(val value: String)
data class University(val name: Name, val deanName: Name)
data class Student(val name: Name, val universityId: UniversityId)
data class Dean(val name: Name)

private val students = mapOf(
    Name("Alice") to Student(Name("Alice"), UniversityId("UCA"))
)

private val universities = mapOf(
    UniversityId("UCA") to University(Name("UCA"), Name("James"))
)

private val deans = mapOf(
    Name("James") to Dean(Name("James"))
)

fun student(name: Name): Either<NotFound, Student> {
    println("called student, $name")
    return students[name]?.right() ?: NotFound.left()
}

fun university(id: UniversityId): Either<NotFound, University> {
    println("called university, $id")
    return universities[id]?.right() ?: NotFound.left()
}

fun dean(name: Name): Either<NotFound, Dean> {
    println("called dean, $name")
    return deans[name]?.right() ?: NotFound.left()
}

suspend fun main() {
    val dean = either<NotFound, Dean> {
        val alice = student(Name("Alice")).bind() // 1ë²ˆ ì¤‘ë‹¨
        val uca = university(alice.universityId).bind() // 2ë²ˆ ì¤‘ë‹¨
        val james = dean(uca.deanName).bind() // 3ë²ˆ ì¤‘ë‹¨
        james
    }

    val notFound = either<NotFound, Dean> {
        val paul = student(Name("Paul")).bind()
        val uca = university(paul.universityId).bind()
        val james = dean(uca.deanName).bind()
        james
    }

    println(dean) // ëª¨ë“  í•¨ìˆ˜ë¥¼ íƒ€ê²Œë¨
    println(notFound) // student í•¨ìˆ˜ë§Œ í˜¸ì¶œí•˜ê²Œ ë¨
}
```

student ì´ë¼ëŠ” í•¨ìˆ˜ì— `Alice` ë¥¼ íŒŒë¼ë¯¸í„°ë¡œ ë„˜ê¸°ë©´, ìì—°ìŠ¤ëŸ½ê²Œ ë‹¤ìŒ í•¨ìˆ˜ì¸ `university` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ì„œ `University` ê°ì²´ë¥¼ ê°€ì ¸ì˜¤ê³ , ê°€ì ¸ì™”ìœ¼ë©´ ë§ˆì°¬ê°€ì§€ë¡œ ìì—°ìŠ¤ëŸ½ê²Œ ë‹¤ìŒ í•¨ìˆ˜ì¸ `dean` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ì„œ `Dean` ê°ì²´ë¥¼ ê°€ì ¸ì˜¤ê²Œ ë©ë‹ˆë‹¤.  

ë§Œì¼ ì•Œ ìˆ˜ ì—†ëŠ” ì´ë¦„ì„ ë˜ì§„ë‹¤ë©´, `Student` ê°ì²´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ, í˜¸ì¶œë˜ì§€ ì•Šê²Œ ë©ë‹ˆë‹¤.

ì°¸ê³ ë‚˜ë§ˆ `either` ë¼ëŠ” `scope` ëŠ” ì½”ë£¨í‹´ scope ì´ë©° arrow ì—ì„œ ì§€ì›í•´ì£¼ëŠ” ì¸í„°í˜ì´ìŠ¤ ì…ë‹ˆë‹¤.  

```kotlin
@Suppress("ClassName")
public object either {
  public inline fun <E, A> eager(crossinline f: suspend EagerEffectScope<E>.() -> A): Either<E, A> =
    eagerEffect(f).toEither()

  public suspend inline operator fun <E, A> invoke(crossinline f: suspend EffectScope<E>.() -> A): Either<E, A> =
    effect(f).toEither()
}
```


## Optics

ë¶ˆë³€ ë°ì´í„°ë¥¼ ë³€í™˜í•˜ê±°ë‚˜ ì—°ì‚°í•˜ëŠ”ë°ì— ìˆì–´ì„œ ì¶”ìƒí™”ëœ ë ˆë²¨  

Optics ì˜ ì¢…ë¥˜ì¤‘ì˜ í•˜ë‚˜ì¸ `Lens` ë¥¼ ì˜ˆì‹œë¡œ ì„¤ëª…í•´ë³´ê² ìŠµë‹ˆë‹¤.  

```kotlin
import arrow.optics.Lens

data class Product(val name: String)
data class OrderItem(val quantity: Long, val product: Product)
data class Order(val purchaserName: String, val orderItem: OrderItem)

// ì´ëŸ¬í•œ ê²ƒì€ arrow kt ì—ì„œ ì§€ì›í•´ì£¼ëŠ” kapt ê¸°ëŠ¥ì„ í†µí•˜ì—¬ ìë™ìƒì„±ì´ ê°€ëŠ¥í•˜ë‹¤. @optics ì–´ë…¸í…Œì´ì…˜ ê¸°ë°˜
private val orderOrderItem: Lens<Order, OrderItem> = Lens(
    get = { it.orderItem },
    set = { order, orderItem -> order.copy(orderItem = orderItem) }
)

private val orderItemProduct: Lens<OrderItem, Product> = Lens(
    get = { it.product },
    set = { orderItem, product -> orderItem.copy(product = product) }
)

private val productName: Lens<Product, String> = Lens(
    get = { it.name },
    set = { product, name -> product.copy(name = name) }
)


fun main() {
    val order = Order(
        purchaserName = "customer",
        orderItem = OrderItem(
            quantity = 1L,
            product = Product(name = "productA")
        )
    )

    val order2 = order.copy(
        orderItem = order.orderItem.copy(
            product = order.orderItem.product.copy(
                name = "productB"
            )
        )
    )

    val orderCopyOnlyProductName: Lens<Order, String> = orderOrderItem compose orderItemProduct compose productName
    val order3 = orderCopyOnlyProductName.modify(order) { "productB" }

    println(order2.orderItem.product.name == order3.orderItem.product.name)
}
```


## ê·¸ ì™¸ ë‚˜ë¨¸ì§€

ì•„ë¬´ë˜ë„ ì œê°€ ë‹¤ ì •ë¦¬í•˜ê¸°ì—ëŠ” ë²…ì°¨ì„œ, ë‚˜ë¨¸ì§€ ëª¨ë“ˆë“¤ì— ëŒ€í•´ì„œëŠ” ê°„ë‹¨í•˜ê²Œ ì†Œê°œë§Œ í• ê¹Œ í•©ë‹ˆë‹¤.

### Fx

ì½”í‹€ë¦°ì˜ `Coroutine` ê³¼ ì¡°í•©í•˜ì—¬, í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì„ ë¹„ë™ê¸°ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µ

### Analysis and Meta

ì½”í‹€ë¦° `compile` ì‹œê°„ì— Arrow ì—ì„œ ì œê³µí•˜ëŠ” ë°ì´í„° ìœ í˜•ì— ëŒ€í•œ ì»´íŒŒì¼ ì—ëŸ¬ë¥¼ íƒì§€í•˜ë„ë¡ ì¶”ê°€í•˜ëŠ” ê¸°ëŠ¥ì„ ì œê³µ  

```kotlin

import arrow.analysis.pre

fun increment(x: Int): Int {
  pre(x > 0) { "value must be positive" }
  return x + 1
}
```

ë¥¼ ì •ì˜í•˜ê³ , `increment` í•¨ìˆ˜ì— -1 ì„ íŒŒë¼ë¯¸í„°ë¡œ í•˜ëŠ” ì½”ë“œë¥¼ ì‘ì„±í•˜ê³ , compile ì„ í•˜ë©´ ì—ëŸ¬ ë°œìƒ 

```kotlin
val example = increment(-1)
```

```text
e: pre-condition `value must be positive` is not satisfied in `increment(-1)`
  -> unsatisfiable constraint: `(-1 > 0)`
```

## ì°¸ê³  ë§í¬

- [Arrow-kt-Core](https://arrow-kt.io/docs/core/)
- [Arrow-kt-Fx](https://arrow-kt.io/docs/fx/)
- [Arrow-kt-Optics](https://arrow-kt.io/docs/optics/traversal/)
- [Arrow-kt-Analysis](https://arrow-kt.io/docs/analysis/)
- [Arrow-kt-Meta](https://arrow-kt.io/docs/meta/)